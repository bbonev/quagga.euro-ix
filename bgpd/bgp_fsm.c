/* BGP-4 Finite State Machine
 * From RFC1771 [A Border Gateway Protocol 4 (BGP-4)]
 * Copyright (C) 1996, 97, 98 Kunihiro Ishiguro
 *
 * Recast for pthreaded bgpd: Copyright (C) Chris Hall (GMCH), Highwayman
 *
 * This file is part of GNU Zebra.
 *
 * GNU Zebra is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published
 * by the Free Software Foundation; either version 2, or (at your
 * option) any later version.
 *
 * GNU Zebra is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GNU Zebra; see the file COPYING.  If not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

#include <zebra.h>

#include "log.h"

#include "bgpd/bgpd.h"
#include "bgpd/bgp_session.h"
#include "bgpd/bgp_connection.h"
#include "bgpd/bgp_notification.h"
#include "bgpd/bgp_fsm.h"
#include "bgpd/bgp_msg_write.h"
#include "bgpd/bgp_msg_read.h"
#include "bgpd/bgp_dump.h"

#include "lib/qtimers.h"
#include "lib/sockunion.h"
#include "lib/qrand.h"
#include "lib/mempool.h"
#include "lib/list_util.h"

#include "bgpd/bgp_debug.h"
#include "bgpd/bgp_network.h"
#include "bgpd/bgp_dump.h"
#include "bgpd/bgp_names.h"

/*==============================================================================
 * The BGP Finite State Machine
 *
 * The working of BGP is described in the RFC (4271) in terms of a finite
 * state machine.  This code attempts to follow the states and events
 * described in the RFC.
 *
 * Some events are queued when they are generated, and it may be a while before
 * they are actioned.  This creates a potential problem: a later event might be
 * rendered "stale" or even invalid by a state change caused by an earlier one
 * -- or, to put it another way, when an event is generated it cannot know that
 * the state may be (effectively) out of date.
 *
 * Some, high priority, events are set by bits in the 'meta_events' in the
 * connection, and these take precedence over all other events.  This, in
 * particular, is how feOpenCollisionDump is sent, ensuring that the
 * connection gets the message before doing anything else.
 *
 * Other, low priority, events are also set by bits in the 'meta_events', in
 * particular all timer events are handled in this way, so that they can be
 * discarded readily if when "stale".
 *
 * Events may be generated by:
 *
 *   * external agency -- in particular enabling and disabling sessions.
 *
 *     These map to feManualStart and feManualStop.
 *
 *     These may be generated at any time and are not dependent on the state
 *     of the FSM when they are generated.  So, the FSM deals with them in
 *     whatever state it is in when it gets to them.
 *
 *   * connection acceptor
 *
 *     Which runs asynchronously, so all states must be ready to process the
 *     event.
 *
 *     There are two events which can affect the FSM:
 *
 *       * feAccepted
 *
 *         which applies only to the secondary (in-bound) connection, or to the
 *         primary connection once the session is established.
 *
 *         If the connection is not up, this is good news:
 *
 *           This can only be in fsActive when it is not delaying_open.
 *
 *           In this state there can be no feIO events !
 *
 *         If the connection is up, this may be bad news:
 *
 *           For fsActive (delaying_open), fsOpenSent and fsOpenConfirm, the
 *           effect of the new in-coming connection is to cause the existing
 *           connection to be dropped.
 *
 *           For fsEstablished the effect depends on Graceful Restart (RFC4724).
 *           If is Graceful Restart, then the current connection and session
 *           will be dropped.  If is not Graceful Restart then the accept()
 *           does not affect the current session, and the event will be ignored.
 *
 *       * feAcceptedOPEN
 *
 *         which applies only if the session is fsEstablished.
 *
 *         Or would apply if we supported CollisionDetectEstablishedState, but
 *         we don't.
 *
 *     Now, the question is what to do if these events are raised before or
 *     after other events for the connection.  These events are asynchronous,
 *     so when we see a new in-bound connection, we do not know whether it
 *     actually occurred before or after any activity on the existing
 *     connection which we may have now seen.  By RFC we expect the far end
 *     to only open up a new connection once it is done with any earlier one,
 *     so we deem all activity we can see on the existing connection to have
 *     occurred first.
 *
 *     So, these are handled as 'meta_events', with a lower priority than
 *     other I/O events, but higher priority than timers.
 *
 *   * I/O
 *
 *     Actual I/O is performed by qfile action, and is limited to the physical
 *     read/write of bytes.  This may (well) generate an feIO (non-RFC) event.
 *
 *     The feIO event is dealt with specially, just before the FSM proper.
 *     If is fsEstablished, then the feIO handler deals with KEEPALIVE and
 *     UPDATE messages and the HoldTimer.  At other times, and for all other
 *     messages and I/O events, each call of the feIO handler may generate at
 *     most one event, which is promptly given to the FSM.  When the FSM
 *     returns, any further feIO stuff will be processed.  (The FSM may, in a
 *     very few cases, push a follow-on event onto the queue, which will be
 *     processed before any further feIO stuff.)
 *
 *     Each time the feIO event handler is invoked, the writer is checked and
 *     any the writer buffer topped up, if possible.
 *
 *     EOF and I/O errors are picked up the feIO event handling -- they are
 *     not reported directly as events.
 *
 *   * timers
 *
 *     The timer action functions set fmXXXX 'meta_events' as required.
 *
 *     Timer events have the lowest priority, and may be discarded on state
 *     change and are discarded when the timer is stopped.
 *
 *   * internally
 *
 *     The processing of one event may generate further event(s), for the FSM
 *     itself and (in a few cases) for the sibling FSM.
 *
 *     Events generated by an FSM for itself are pushed onto the front of the
 *     event queue, so the FSM can ensure that there aren't any state issues.
 *
 *     One FSM may generate feOpenCollisionDump for another -- which is
 *     handled as a high priority meta_event.
 *
 * In general the FSM manages connections, but there is some interaction with
 * the session, particularly when connections enter/leave fsEstablished !
 *
 * TODO: restore NSF
 *
 *------------------------------------------------------------------------------
 * Connect and Accept (aka Active) Connections
 *
 * To support BGP's "symmetrical" open strategy, this code allows for two
 * connections to be made for a session -- one connect() and one accept().
 * If two connections are made, only one will reach fsOpenConfirm state and
 * hence fsEstablished.
 *
 * When a session is enabled, the allowed connections are initialised and
 * an feManualStart event issued for each one.
 *
 * The listeners (in bgp_network) will only accept connections from addresses
 * known to be peer addresses, and then only when the FSM is ready for them.
 * The accept field in the peer_index entry (see bgp_peer_index) is maintained
 * by this code -- the accept field (when set) points to the secondary
 * connection of the session.
 *
 * As per the RFC, collision detection/resolution is performed when an OPEN
 * message is received -- that is, as the connection attempts to advance to
 * sOpenConfirm state.  At that point, if the sibling is in sOpenConfirm state,
 * then one of the two connections is closed (and will go sIdle once the
 * NOTIFICATION has been sent).
 *
 * See below for a discussion of the fall back to sIdle -- the losing connection
 * will remain comatose until the winner either reaches sEstablished (when the
 * loser is snuffed out) or the winner falls back to sIdle (when the
 * IdleHoldTimer for the loser is set, and it will wake up in due course).
 *
 * NB: the RFC talks of matching source/destination and destination/source
 *     addresses of connections in order to detect collisions.  This code
 *     uses only the far end address to detect collisions.  It does so
 *     implicitly because the in-bound connection is matched with the out-
 *     bound one using the peer's known IP address -- effectively its name.
 *
 *     [It is not deemed relevant if the local addresses for the in- and out-
 *      bound connections are different.]
 *
 *     The RFC further says "the local system MUST examine all of its
 *     connections that are in OpenConfirm state" ... "If, among these
 *     connections, there is a connection to a remote BGP speaker whose BGP
 *     identifier equals the one in the OPEN message, and this connection
 *     collides with [it]" ... then must resolve the collision.
 *
 *     This code almost does this, but:
 *
 *       * there can only be one connection that collides (i.e. only one other
 *         which has the same remote end address), and that is the sibling
 *         connection.
 *
 *         So there's not a lot of "examining" to be done.
 *
 *       * the RFC seems to accept that there could be two distinct connections
 *         with the same remote end address, but *different* BGP Identifiers.
 *
 *         As far as Quagga is concerned, that is impossible.  The remote end
 *         IP address is the name of the peering session, and there cannot
 *         be two peering sessions with the same name.  It follows that Quagga
 *         requires that the "My AS" and the "BGP Identifier" entries in the
 *         OPEN messages from a given remote end IP address MUST MATCH !
 *
 *------------------------------------------------------------------------------
 * The FSM proceeds in three basic phases:
 *
 *   1) attempting to establish a TCP connection: sIdle/sActive/sConnect
 *
 *      In this phase there is no connection for the other end to close !
 *
 *      sIdle is a "stutter step" which becomes longer each time the FSM falls
 *      back to sIdle, which it does if the process fails in sOpenSent or
 *      sOpenConfirm.
 *
 *      Cannot fail in sIdle !
 *
 *      In sConnect any failure causes the FSM to stop trying to connect.  It
 *      does nothing further until the end of the ConnectRetryTimer interval
 *      -- at which point it will try again, re-charging the timer.
 *      (That is usually 120 seconds (less jitter) -- so in the worst case, it
 *      will try to do something impossible every 90-120 seconds.)
 *
 *      RFC4271 ALERT:
 *
 *        The RFC specifies that if there is a TCP failure during Connect,
 *        then it proceeds to Active, and will wait a full ConnectRetryTime
 *        before reverting to Connect state, and attempting to open another
 *        connection.
 *
 *        This code waits until the end of the
 *
 *
 *      A connection may fall back to sIdle from sOpenSent/sOpenConfirm (see
 *      below).  While one connection is sOpenSent or sOpenConfirm we don't
 *      really want to start another TCP connection in competition.  So, on
 *      entry to sIdle:
 *
 *        * if a sibling exists and is in sOpenSent or sOpenConfirm:
 *
 *            - do not change the IdleHoldTimer interval.
 *            - unset the IdleHoldTimer.
 *            - set self "comatose".
 *
 *        * otherwise:
 *
 *            - increase the IdleHoldTimer interval.
 *            - set the IdleHoldTimer (with jitter).
 *
 *          and if a sibling exists and is comatose:
 *
 *            - set *its* IdleHoldTimer (with jitter).
 *            - clear *its* comatose flag.
 *
 *      The effect is that if both connections make it to sOpenSent, then only
 *      when *both* fall back to sIdle will the FSM try to make any new TCP
 *      connections.
 *
 *      The IdleHoldTimer increases up to 120 seconds.  In the worst case, the
 *      far end repeatedly makes outgoing connection attempts, and immediately
 *      drops them.  In which case, the IdleHoldTimer grows, and the disruption
 *      reduces to once every 90-120 seconds !
 *
 *   2) attempting to establish a BGP session: sOpenSent/sOpenConfirm
 *
 *      If something goes wrong, or the other end closes the connection (with
 *      or without notification) the FSM will loop back to sIdle state.  Also,
 *      when collision resolution closes one connection it too loops back to
 *      sIdle (see above).
 *
 *      Both connections may reach sOpenSent.  Only one at once can reach
 *      sOpenConfirm -- collision resolution sees to that.
 *
 *      Note that while a NOTIFICATION is being sent the connection stays
 *      in sOpenSent/sOpenConfirm state.
 *
 *   3) BGP session established
 *
 *      If something goes wrong, or the other end closes the connection
 *      (with or without notification) will stop the session.
 *
 * Only three things bring the FSM to a dead stop, and stop the session:
 *
 *   1) the Routeing Engine disabling the session.
 *
 *   2) invalid events -- which are assumed to be bugs, really.
 *
 *   3) anything that stops the session while in sEstablished state.
 *
 * This means that the FSM will plough on trying to establish connections with
 * configured peers, even in circumstances when the likelihood of success
 * appears slim to vanishing.  However, the Routeing Engine and the operator
 * are responsible for the decision to start and to stop trying to connect.
 *
 */

/*==============================================================================
 * Starting up and closing down sessions and connections.
 */
static void bgp_fsm_admin_event(bgp_connection connection,
                                     bgp_fsm_event_t fsm_event, bgp_note note) ;
static void bgp_fsm_raise_meta_event(bgp_connection connection,
                                                      bgp_fsm_meta_t fsm_meta) ;

/*------------------------------------------------------------------------------
 * Start the given session, if csRun etc -- must be sReady.
 *
 * If !csRun or have neither csMayConnect nor csMayAccept, do nothing (stays
 * sReady until some change in the conn_state).
 *
 * Otherwise, this is the first step in the FSM:
 *
 *   * session changes to sAcquiring
 *
 *   * connections start in bgp_fsNULL, with an feManualStart event.
 */
extern void
bgp_fsm_start_session(bgp_session session)
{
  bgp_conn_state_t conn_state ;

  qassert(session->state == bgp_sReady) ;

  qassert(session->connections[bc_connect] == NULL) ;
  qassert(session->connections[bc_accept]  == NULL) ;
  qassert(session->connections[bc_estd]    == NULL) ;

  memset(session->connections, 0, sizeof(session->connections)) ;

  /* Should we go ahead and start one or two connections ?
   */
  conn_state = session->cops_conf->conn_state ;

  if ((conn_state & (bgp_csRun | bgp_csMayConnect | bgp_csMayAccept))
                                                                  <= bgp_csRun)
    return ;

  confirm(bgp_csMayConnect < bgp_csRun) ;
  confirm(bgp_csMayAccept  < bgp_csRun) ;

  /* Accept and/or Connect connections enabled now
   */
  if (conn_state & bgp_csMayConnect)
    bgp_connection_start(session, bc_connect) ;

  if (conn_state & bgp_csMayAccept)
    bgp_connection_start(session, bc_accept) ;

  session->state = bgp_sAcquiring ;
} ;

/*------------------------------------------------------------------------------
 * Ultimate exception -- disable the session
 *
 * If session is enabled (one or both connections exist), then brings it to
 * a halt, issuing the given notification (if any).
 *
 * If neither connection exists (which implies the session has already been
 * disabled, or never got off the ground), then has nothing to do, and discards
 * the notification.
 *
 * In all cases, returns a bgp_session_eDisabled event.
 *
 * NB: takes responsibility for the given notification.
 *
 * Returns:  NULL
 */
extern bgp_note
bgp_fsm_stop_session(bgp_session session, bgp_note note)
{
  bgp_connection connection ;

  if ((connection = session->connections[bc_connect]) != NULL)
    bgp_fsm_stop_connection(connection, bgp_note_dup(note)) ;

  if ((connection = session->connections[bc_accept]) != NULL)
    bgp_fsm_stop_connection(connection, bgp_note_dup(note)) ;

  return bgp_note_free(note) ;
} ;

/*------------------------------------------------------------------------------
 * Start FSM running for the given (brand new) connection.
 */
extern void
bgp_fsm_start_connection(bgp_connection connection)
{
  qassert(connection->fsm_state == bgp_fsNULL) ;

  /* Set an fmRun meta-event so is set running and is added to the ring.
   *
   * Then throw a manual start to set a high priority event... so that the
   * fsNULL FSM state has a very, very restricted set of things to worry about.
   */
  bgp_fsm_raise_meta_event(connection, bgp_fmRun) ;
  bgp_fsm_admin_event(connection, bgp_feManualStart, NULL) ;
} ;

/*------------------------------------------------------------------------------
 * Restart the given connection.
 *
 * NB: takes responsibility for the given notification.
 */
extern void
bgp_fsm_restart_connection(bgp_connection connection, bgp_note note)
{
  bgp_fsm_admin_event(connection, bgp_feRestart, note) ;
} ;

/*------------------------------------------------------------------------------
 * Stop the given connection.
 *
 * NB: takes responsibility for the given notification.
 */
extern void
bgp_fsm_stop_connection(bgp_connection connection, bgp_note note)
{
  bgp_fsm_admin_event(connection, bgp_feManualStop, note) ;
} ;

/*==============================================================================
 * The bgp_fsm_event mechanics.
 *
 * The ring of connections with active events.
 */
static bgp_connection fsm_ring = NULL ;

static bgp_fsm_event_t bgp_fsm_meta_event(bgp_connection connection,
                                                        bgp_fsm_eqb eqb) ;
static bgp_fsm_event_t bgp_fsm_do_io(bgp_connection connection,
                                                            bgp_fsm_eqb eqb) ;
static void bgp_fsm_event_handle(bgp_connection connection,
                                   bgp_fsm_event_t fsm_event, bgp_fsm_eqb eqb) ;

/*------------------------------------------------------------------------------
 * Initialise the FSM mechanics.
 */
extern void
bgp_fsms_init(void)
{
  rdl_init(fsm_ring) ;
} ;

/*------------------------------------------------------------------------------
 * Stop the FSM mechanics -- walk the list of connections with events pending
 * and empty all their event queues.
 */
extern void
bgp_fsms_stop(void)
{
  while (fsm_ring != NULL)
    bgp_fsm_events_flush(fsm_ring) ;
} ;

/*------------------------------------------------------------------------------
 * Flush all events (if any) for the given connection, and remove it from
 *                                                       the fsm_ring (if there)
 */
extern void
bgp_fsm_events_flush(bgp_connection connection)
{
  connection->meta_events = bgp_fmStop ;

  if (rdl_is_on(connection, event_ring))
    rdl_del(fsm_ring, connection, event_ring) ;
} ;

/*------------------------------------------------------------------------------
 * Raising a straightforward event
 */
static void
bgp_fsm_raise_meta_event(bgp_connection connection, bgp_fsm_meta_t fsm_meta)
{
  connection->meta_events |= fsm_meta ;

  if (!rdl_is_on(connection, event_ring))
    rdl_append(fsm_ring, connection, event_ring) ;
} ;

/*------------------------------------------------------------------------------
 * Run any and all pending FSM Events.
 *
 * Returns:  count of events handled
 */
extern int
bgp_fsm_events_run(void)
{
  bgp_connection  connection ;
  bgp_fsm_eqb_t   eqb[1] ;
  int count ;

  /* Empty the queue of connections with events pending.
   *
   * When an event is processed it is first taken off the connection's
   * queue.  The event handling may generate further events, at the front or
   * back of that queue.
   *
   * Generally there will only ever be one event outstanding for a connection.
   *
   * Connections are handled "round-robin", processing one event at a time, and
   * removing connections which have no events left.
   *
   * Generally events in one connection are entirely independent of events in
   * another.  For collision handling one connection may send an event to
   * another.  There could be other instances, HOWEVER, the event handler MUST
   * NOT generate ANY event for itself or any other connection which DEPENDS on
   * being processed in any order wrt events for itself, the target connection
   * or any other connection.
   */
  memset(eqb, 0, sizeof(*eqb)) ;
  count = 0 ;
  while ((connection = rdl_head(fsm_ring)) != NULL)
    {
      bgp_fsm_meta_t  meta ;
      bgp_fsm_event_t fsm_event ;

      count += 1 ;

      qassert(eqb->note  == NULL) ;
      qassert(eqb->err   == 0) ;

      meta = connection->meta_events & (bgp_fmAdmin | bgp_fmSocket | bgp_fmIO) ;

      if (meta == bgp_fmIO)
        fsm_event = bgp_fsm_do_io(connection, eqb) ;
      else
        fsm_event = bgp_fsm_meta_event(connection, eqb) ;

      if (fsm_event != bgp_feNULL)
        {
          /* Let the full FSM loose on the event...
           *
           * ... it may take responsibility of the given notification, if it
           * wishes.
           */
          bgp_fsm_event_handle(connection, fsm_event, eqb) ;

          bgp_note_free(eqb->note) ;
          eqb->err = 0 ;
        } ;

      meta = connection->meta_events ;
      confirm((bgp_fmRun == 1) && (bgp_fmStop < bgp_fmRun)) ;

      if (meta > bgp_fmRun)
        fsm_ring = rdl_next(connection, event_ring) ;   /* round robin  */
      else
        {
          rdl_del(fsm_ring, connection, event_ring) ;

          if (meta == bgp_fmStop)
            bgp_connection_free(connection) ;
        } ;
    } ;

  return count ;
} ;

/*------------------------------------------------------------------------------
 * Generate a meta-event !
 *
 * The priority of meta-events is not accidental.
 *
 * The fmAdmin events have absolute priority.  This is important for the
 * Collision Resolution stuff -- where, once a connection has lost out, it
 * MUST drop to fsIdle or fsStop, notwithstanding what other events might
 * be pending -- which events might otherwise advance the FSM to fsOpenConfirm
 * or fsEstablished.
 *
 * The fmSocket events have the next highest priority.  Much of the time
 * this does not matter, since before a connection is up there can be no IO.
 * Where a connection has started, if is the Accept side, then that can be
 * interrupted by a new Acceptor event.  It is tidy for those to be processed
 * before any IO or timers change the state of the FSM.
 *
 * The fmIO portmanteau event has higher priority than the timers, which have
 * the lowest priority.
 *
 * NB: fills in any eqb->notification -- but NOT the eqb->fsm_event.
 */
static bgp_fsm_event_t
bgp_fsm_meta_event(bgp_connection connection, bgp_fsm_eqb eqb)
{
  bgp_fsm_meta_t  meta ;
  bgp_fsm_event_t fsm_event ;

  /* fmAdmin and fmSocket take priority.
   */
  meta = connection->meta_events ;

  if (meta & (bgp_fmAdmin | bgp_fmSocket))
    {
      /* fmAdmin takes priority over fmSocket.
       */
      if (meta & bgp_fmAdmin)
        {
          /* fmAdmin maps to Stop and Dump events
           */
          fsm_event = connection->admin_event ;

          qassert( (fsm_event == bgp_feManualStop)        ||
                   (fsm_event == bgp_feAutomaticStop)     ||
                   (fsm_event == bgp_feOpenCollisionDump) ||
                   (fsm_event == bgp_feManualStart)       ||
                   (fsm_event == bgp_feRestart)           ||
                   (fsm_event == bgp_feBGPOpenMsgErr) ) ;
          eqb->note = connection->admin_note ;

          connection->admin_event = bgp_feNULL ;
          connection->admin_note  = NULL ;

          meta ^= bgp_fmAdmin ;
        }
      else
        {
          /* fmSocket maps to:
           *
           *   feConnected
           *   feConnectFailed,
           *   feAccepted
           *   feAcceptOPEN,
           *   feError
           */
          fsm_event = connection->socket_event ;

          qassert( (fsm_event == bgp_feConnected)     ||
                   (fsm_event == bgp_feConnectFailed) ||
                   (fsm_event == bgp_feAccepted)      ||
                   (fsm_event == bgp_feAcceptOPEN) ||
                   (fsm_event == bgp_feError) ) ;

          connection->socket_event = bgp_feNULL ;

          meta ^= bgp_fmSocket ;
        } ;
    }
  else if (meta & bgp_fmIO)
    {
      /* Don't expect to see this here...
       */
      qassert(false) ;
      fsm_event = bgp_feNULL ;
    }
  else if (meta & (bgp_fmHoldTimer | bgp_fmKeepaliveTimer))
    {
      /* One of the timers
       */
      bgp_fsm_timer ft ;

      if (meta & bgp_fmHoldTimer)
        {
          ft = connection->hold_timer ;
          qassert( (ft->fsm_event == bgp_feConnectRetryTimer_Expires) ||
                   (ft->fsm_event == bgp_feHoldTimer_Expires)         ||
                   (ft->fsm_event == bgp_feDelayOpenTimer_Expires)    ||
                   (ft->fsm_event == bgp_feIdleHoldTimer_Expires) ) ;
          qassert(ft->fsm_meta == bgp_fmHoldTimer) ;
          qassert(ft->state == bfts_expired) ;
        }
      else
        {
          ft = connection->keepalive_timer ;
          qassert(ft->fsm_event == bgp_feKeepaliveTimer_Expires) ;
          qassert(ft->fsm_meta  == bgp_fmKeepaliveTimer) ;
          qassert(ft->state == bfts_expired) ;
        } ;

      ft->state = bfts_stopped ;
      meta     &= ~ft->fsm_meta ;
      fsm_event = ft->fsm_event ;
    }
  else if (meta == bgp_fmRun)
    {
      /* Generally, we don't expect fmRun on its own... though we do use it
       * to get the ball rolling.
       *
       * But... we allow an empty set of meta events to flow through.
       */
      if (connection->fsm_state == bgp_fsNULL)
        fsm_event = bgp_feManualStart ;
      else
        fsm_event = bgp_feNULL ;
    }
  else
    {
      /* We *really* do not expect to be here for fmStop... and certainly
       * NOT for unrecognised fmXxxx.
       */
      qassert(meta == bgp_fmStop) ;

      meta      = bgp_fmStop ;          /* force the issue      */
      fsm_event = bgp_feNULL ;
    }

  /* Update meta_events and return the event
   */
  connection->meta_events = meta ;
  return fsm_event ;
} ;

/*==============================================================================
 * Raising FSM Events or otherwise dealing with events which affect an FSM.
 *
 *
 *
 */

/*------------------------------------------------------------------------------
 * Raise the given "admin" event.
 *
 * Accepts a small number of feXxxx, and sets the event iff there isn't a
 * higher priority event already raised.
 *
 * NB: takes responsibility for the given notification.
 */
static void
bgp_fsm_admin_event(bgp_connection connection, bgp_fsm_event_t fsm_event,
                                                                  bgp_note note)
{
  static const byte admin_event_priority[bgp_fe_count] =
    {
      [bgp_feManualStop]        = 1,
      [bgp_feAutomaticStop]     = 2,
      [bgp_feManualStart]       = 3,
      [bgp_feOpenCollisionDump] = 4,
      [bgp_feRestart]           = 5,
      [bgp_feBGPOpenMsgErr]     = 6,
    } ;

  uint current_priority, new_priority ;

  current_priority = 0 ;
  if (connection->meta_events & bgp_fmAdmin)
    {
      /* We have an existing fmAdmin... find its priority
       */
      if (connection->admin_event < bgp_fe_count)
        current_priority = admin_event_priority[connection->admin_event] ;

      qassert(current_priority != 0) ;
    } ;

  new_priority = 0 ;
  if (fsm_event < bgp_fe_count)
    new_priority = admin_event_priority[fsm_event] ;

  qassert (new_priority != 0) ;

  if ((new_priority >= current_priority) && (new_priority != 0))
    {
      bgp_note_free(connection->admin_note) ;

      connection->admin_event = fsm_event ;
      connection->admin_note  = note ;

      bgp_fsm_raise_meta_event(connection, bgp_fmAdmin) ;

      note = NULL ;
    } ;

  bgp_note_free(note) ;
} ;

/*------------------------------------------------------------------------------
 * Signal completion of a connect() for the given socket -- successful or not.
 *
 * This is used by the connect() qpselect action.  It is also used if a
 * connect() attempt fails immediately -- in which case there is no qfile.
 *
 * If err == 0, then all is well: start the connection (can now write to it)
 *                                and generate eTCP_opened event
 *
 * If err is one of:
 *
 *   EADDRNOTAVAIL:
 *   EADDRINUSE:
 *   ECONNREFUSED:
 *   ECONNRESET:
 *   ENETDOWN:
 *   ENETUNREACH:
 *   EPIPE:
 *
 * generate feConnectFailed event.
 *
 * If the err is:
 *
 *    ETIMEDOUT
 *
 * we do not report any event at all -- the ConnectRetryTimer will deal with
 * this case.
 *
 * Other errors are reported as eTCP_error event.
 *
 * In all error cases (including ETIMEDOUT) the connection (if any) is downed.
 *
 * In all cases, except ETIMEDOUT, the ConnectRetryTimer is stopped.  If that
 * timer has already expired, but its event has not yet been processed, then
 * it will be treated as stale, and discarded.
 *
 * NB: in any case on entry to this function the file is *disabled* in all
 *     modes.
 */
extern void
bgp_fsm_connect_event(bgp_connection connection, int sock_fd, int err)
{
  bgp_fsm_event_t  fsm_event ;

  qassert(connection != NULL) ;

  switch (err)
    {
      /* This is a successful connect()
       */
      case 0:
        if (BGP_DEBUG(fsm, FSM))
          plog_debug(connection->lox.log,
                                       "%s [FSM] BGP connection opened fd %d",
                                                connection->lox.name, sock_fd) ;
        fsm_event = bgp_feConnected ;
        break ;

      /* These are all reasons for the connect() to fail because it is not
       * possible to reach the other end -- so report as eTCP_open_failed.
       *
       * Except for ETIMEDOUT -- which we don't report at all:
       *
       *    this means that the connect() has timed out, before the
       *    ConnectRetryTimer has gone off, so we don't need to do anything
       *    until that timer expires.
       *
       * In any case, we are done with the connection (if any).
       */
      case EADDRNOTAVAIL:
      case EADDRINUSE:
      case ECONNREFUSED:
      case ECONNRESET:
      case ENETDOWN:
      case ENETUNREACH:
      case EPIPE:
      case ETIMEDOUT:
        if (BGP_DEBUG(fsm, FSM) && (sock_fd >= 0))
          plog_debug(connection->lox.log,
                        "%s [FSM] BGP connect() failed fd %d (%s)",
                            connection->lox.name, sock_fd, errtoa(err, 0).str) ;

        if (err != ETIMEDOUT)
          fsm_event = bgp_feConnectFailed ;

        bgp_connection_down(connection) ;
        break ;

      /* Anything else is some general I/O or socket error.  A failure to
       * even get the socket up is signalled as sock_fd < 0 !
       *
       * We are done with the connection (if any).
       */
      default:
        fsm_event = bgp_fsm_io_failed(&connection->lox, sock_fd, err,
                                                                    "connect") ;
        bgp_connection_down(connection) ;
        break ;
    } ;

  if (fsm_event != bgp_feNULL)
    {
      bgp_fsm_timer_stop(connection->hold_timer) ;

      connection->socket_err   = err ;
      connection->socket_event = fsm_event ;

      bgp_fsm_raise_meta_event(connection, bgp_fmSocket) ;
    } ;
} ;

/*------------------------------------------------------------------------------
 * Have some sort of I/O error or EOF.
 *
 * Log the issue, as required.  The 'where' argument may (for example) be:
 *
 *    * "read"    for read() errors      )
 *    * "write"   for write() errors     ) duh
 *    * "connect" for connect() errors   )
 *
 * The following are reported as 'feDown', and logged only for DEBUG:
 *
 *   0, ECONNRESET, ENETDOWN, ENETUNREACH or ETIMEDOUT
 *
 * ...these are deemed to be largely "expected" networking issues.
 *
 * All other errors are reported as "feError", and logged as Errors.
 *
 * Returns:  required fsm_event type.
 *
 * NB: does not raise any event -- so can be used by 'acceptor' functions.
 */
extern bgp_fsm_event_t
bgp_fsm_io_failed(bgp_connection_logging plox, int sock_fd, int err,
                                                              const char* where)
{
  switch (err)
    {
      case 0:
        if (BGP_DEBUG(fsm, FSM))
          plog_debug(plox->log, "%s [FSM] BGP connection %s closed fd %d",
                                                   plox->name, where, sock_fd) ;
        return bgp_feDown ;

      case ECONNRESET:
      case ENETDOWN:
      case ENETUNREACH:
      case ETIMEDOUT:
        if (BGP_DEBUG(fsm, FSM))
          plog_debug(plox->log, "%s [FSM] BGP connection %s closed fd %d (%s)",
                               plox->name, where, sock_fd, errtoa(err, 0).str) ;
        return bgp_feDown ;

      default:
        if (sock_fd >= fd_first)
          plog_err (plox->log, "%s [Error] bgp I/O error fd %d (%s): %s",
                               plox->name, sock_fd, where, errtoa(err, 0).str) ;
        else
          plog_err (plox->log, "%s [Error] bgp socket error (%s): %s",
                                        plox->name, where, errtoa(err, 0).str) ;
        return bgp_feError ;
    } ;
} ;

/*------------------------------------------------------------------------------
 * Signal an acceptor feAccepted or feAcceptOPEN event.
 *
 * Action depends on the state of the session:
 *
 *   * sAcquiring    => there is a secondary connection, which may want to know
 *                      about this.
 *
 *     Set the fmSocket event.
 *
 *   * sEstablised   => there is a primary connection which may want to know
 *                      about this.
 *
 *     Set the fmSocket event.
 *
 *   * other states  => the acceptor is on its own !
 *
 * Note that this "latches" the event, until the FSM gets round to dealing with
 * with it.  Thus:
 *
 *   * if the FSM is fsActive with no open connection, it will co-opt any
 *     (then) active acceptor connection, if it is bacs_open_awaited or
 *     bacs_open_received, and proceed from there.
 *
 *   * if the FSM is fsEstablished by the time it sees the event, then it will
 *     (a) if is Graceful Restart, drop the session, or (b) if not Graceful
 *     Restart, will ignore feAccepted, but may process an feAccepted_OPEN.
 *
 *   * if the FSM is fsNULL, fsIdle, fsConnect or fsStop, the acceptor
 *     events are irrelevant and are ignored.
 *
 *   * at all other times, any number of feAccepted and/or feAcceptOPEN
 *     events are fatal to the current connection, and it will proceed to
 *     fsIdle, and come back to fsActive.
 *
 * Note also that this overwrites any pending socket_event, since a further
 * accept() will have discarded the OPEN from an earlier one !
 */
extern void
bgp_fsm_accept_event(bgp_session session, bgp_fsm_event_t fsm_event)
{
  bgp_connection  connection ;

  qassert( (fsm_event == bgp_feAccepted) ||
           (fsm_event == bgp_feAcceptOPEN) ) ;

  switch (session->state)
    {
      case bgp_sAcquiring:
        connection = session->connections[bc_accept] ;

        if (connection == NULL)
          {
            /* We do not have an accept connection, in sAcquiring state,
             * so... we must not be prepared to accept !
             */
            qassert(!(session->cops_conf->conn_state & bgp_csMayAccept)) ;
            fsm_event = bgp_feNULL ;            /* ignore       */
          }
        else
          {
            /* We have an accept connection, in sAcquiring state.
             */
            switch (connection->fsm_state)
              {
                /* These states are valid for sAcquiring
                 *
                 * We do not collect acceptor events while fsIdle, the current
                 * acceptor state will be checked when leaves fsIdle in its way
                 * to fsActive.
                 *
                 * Fir the other states, we set the given event pending.
                 */
                case bgp_fsIdle:
                  fsm_event = bgp_feNULL ;      /* suppress     */
                  break ;

                case bgp_fsActive:
                case bgp_fsOpenSent:
                case bgp_fsOpenConfirm:
                  break ;

                /* These states are impossible for sAcquiring on the secondary
                 */
                case bgp_fsNULL:
                case bgp_fsConnect:
                case bgp_fsEstablished:
                case bgp_fsStop:
                default:
                  qassert(false) ;

                  fsm_event = bgp_feNULL ;      /* suppress     */
                  break ;
              } ;
          } ;
        break ;

      /* Can only have one live connection in sEstablished, and it must be
       * fsEstablished !
       */
      case bgp_sEstablished:
        connection = session->connections[bc_estd] ;

        if ( (connection == NULL) ||
             (connection->fsm_state != bgp_fsEstablished) )
          {
            qassert(false) ;
            fsm_event = bgp_feNULL ;      /* suppress     */
          } ;
        break ;

      /* In all other states, what the acceptor is doing is of no interest to
       * the FSM.
       */
      default:
        fsm_event = bgp_feNULL ;        /* suppress     */
        break ;
    } ;

  if (fsm_event != bgp_feNULL)
    {
      connection->socket_event = fsm_event ;
      bgp_fsm_raise_meta_event(connection, bgp_fmSocket) ;
    } ;
} ;


/*==============================================================================
 * For debug...
 */
#define BGP_FSM_DEBUG(connection, message) \
  if (BGP_DEBUG (fsm, FSM)) \
    plog_debug (connection->lox.log, "%s [FSM] " message, connection->lox.host)

/*==============================================================================
 * Finite State Machine States -- see also the RFC: RFC 4271
 *
 *   0. bgp_fsNULL  -- not an RFC state.
 *
 *      When a connection is initialised it is in bgp_fsNULL, and will then
 *      be pushed into bgp_fsIdle, with initial IdleHoldTimer running.
 *
 *   1. bgp_fsIdle
 *
 *      This code implements:  AllowAutomaticStart
 *                             DampPeerOscillations and IdleHoldTimer
 *
 *      This is not (quite) the RFC Idle state.  In the RFC "Idle" is a do
 *      nothing, wait for a start event state.  The RFC events are:
 *
 *         1. ManualStart
 *         4. ManualStart_with_Passive
 *
 *         3. AutomaticStart
 *         5. AutomaticStart_with_Passive
 *         6. AutomaticStart_with_Damp
 *         7. AutomaticStart_with_Damp_and_Passive
 *
 *        13. IdleHoldTimer_Expires
 *
 *      Where the RFC specifies a transition to Idle it is possible that some
 *      undefined mechanism will generate any of the AutomaticStart events.
 *
 *      In this code the functions of the RFC Idle state are divided into:
 *
 *        * fsNULL
 *
 *          which receives the ManualStart events... and moves to fsIdle
 *
 *        * fsIdle
 *
 *          This has two sub-states:
 *
 *            * not 'stopping'
 *
 *              where the FSM is waits on the IdleHoldTimer -- but see below
 *              for interaction with sending notifications and such like.
 *
 *              ie. RFC Idle after any of the AutomaticStart events.
 *
 *              can fall back to fsIdle from, for example fsOpenSent, and then
 *              start again trying to acquire a session.
 *
 *              If DampPeerOscillations is turned off, the IdleHoldTimer is set
 *              to a small value.
 *
 *            * 'stopping'
 *
 *               where the FSM is in RFC terms Idle, but no AutomaticStart is
 *               possible.
 *
 *               For the BGP Engine, once a session has reached Established
 *               state, any failure causes everything to stop, the BGP Engine
 *               cannot automatically require a session -- the Routeing
 *               Engine must adjust itself to the end of the session, and then
 *               it may restart the BGP Engine.
 *
 *          The handling of NOTIFICATION messages and such is pretty much the
 *          same for stopping and not stopping cases -- so we do not have a
 *          separate stoppin state.
 *
 *      The Passive and Damp properties are set while the FSM is in fsNULL
 *      state... so this code is not interested in the qualified Start events.
 *
 *      The RFC also mentions:
 *
 *         2. ManualStop
 *         8. AutomaticStop
 *
 *      Which are deemed to have no effect in Idle.  For the BGP Engine,
 *      stopping an FSM sends it to fsIdle + stopping state, and passes the
 *      session back to the Routeing Engine.
 *
 *      FWIW: the RFC should probably say that these events should stop any
 *            IdleHoldTimer
 *
 *      So, fsIdle is the RFC state *with* DampPeerOscillations, *while* is
 *      waiting for the IdleHoldTimer.  And fsNULL is, in essence, the
 *      rest of the RFC Idle state.
 *
 *      Now, fsIdle is a little more complicated that the above suggests:
 *
 *        * sending notification
 *
 *          when falls back to fsIdle a connection has come up, but has failed
 *          to reach fsEstablished.  Unless that was caused by an I/O failure,
 *          a notification message will have been sent.  We want that to have
 *          been written away before we leave fsIdle, or to at least have
 *          given a reasonable time for that to have happened.
 *
 *        * avoiding collisions
 *
 *          when coming out of fsIdle, if there is a sibling, which has
 *          reached fsOpenSent or fsOpenConfirm, the connection will hold back
 *          from going to fsConnect or fsActive for a short period, once.
 *
 *          In this case, if the other connection has reached fsOpenSent then
 *          at the least, when the other end sees the OPEN it will send OPEN
 *          (if not already sent) or NOTIFICATION.  If the other connection has
 *          has reached fsOpenConfirm then we have sent KEEPALIVE and we are
 *          waiting for a KEEPALIVE to signal all is well.  Unless there is
 *          an I/O failure, the process will soon reach fsEstablished, and
 *          there is no point starting a new alternative connection now.
 *
 *          If the other connection fails while this one is waiting, then it
 *          will go into fsIdle etc.  This connection will start up shortly.
 *
 *          If the other connection simply stops, then it will eventually time
 *          out, but this connection will start up in the meantime, no matter
 *          what.
 *
 *          If this is the inbound FSM, then if the other end has already
 *          initiated a connection, or does so while is in this IdleHoldTime
 *          extension, then this adds a short delay before considering that
 *          connection.  If the other end has decided against the other
 *          (inbound from its perspective) connection for some reason, then
 *          this is a (short) extra delay.  Note that the delay is small
 *          compared to the maximum IdleHoldTime
 *
 *   2. bgp_fsConnect
 *
 *      For the RFC the Connect state is where an FSM is waiting for an
 *      outbound ("active") or an inbound ("passive") connection.
 *
 *      The RFC is IMHO confused.  It speaks of "one FSM per connection"
 *      (8.2.1.2), but then goes on to describe the "BGP peer FSM" (8.2.2).
 *      So, in Connect state the FSM has to deal with both inbound and outbound
 *      connection events, and proceeds to OpenSent if either turn up.
 *
 *      On entry to Connect state an outgoing connection is initiated, and
 *      the ConnectRetryTimer is set:
 *
 *        * if the connection fails in some way (ie something happens but is
 *          unsuccessful) then the connection attempt is discarded, the
 *          ConnectRetryTimer is restarted and goes to Active.
 *
 *          In Active state, if the ConnectRetryTimer goes off, re-enters
 *          Connect state.
 *
 *        * if nothing happens, the connection attempt is discarded, and the
 *          FSM loops back and re-enters Connect.
 *
 *      Note that after a failure, it will be a full ConnectRetryTime before
 *      another attempt to connect is made.
 *
 *      This code runs a separate FSM for outbound and inbound connections.
 *      The fsConnect state is only used for outbound connections.
 *
 *      When a connection comes up:
 *
 *        * an OPEN is sent and goes to OpenSent -- unless DelayOpen is set.
 *
 *        * starts the DelayOpenTimer and enters a sub-state of Connect waiting
 *          for the timer or for an OPEN to be received -- at which point
 *          an OPEN is sent and goes to OpenSent.
 *
 *      This code does not (currently) implement DelayOpen.
 *
 *   3. bgp_fsActive
 *
 *      For the RFC the Active state is where an FSM is waiting for an
 *      inbound ("passive") connection *only*.  That is, there is no outbound
 *      ("active") connection in Active state -- so there.
 *
 *      This code runs a separate FSM for outbound and inbound connections.
 *      The fsActive state is only used for inbound ("passive") connections.
 *
 *      So... fsActive does not have to deal with ConnectRetryTimer, or
 *      anything else to do with outbound connections.  EXCEPT: the RFC
 *      description of a "PassiveTcpEstablishment" (8.1.1) says:
 *
 *        "This option indicates that the BGP FSM will passively wait
 *         for the remote BGP peer to establish the BGP TCP connection."
 *
 *      HOWEVER, the transition from Idle to Active sets the ConnectRetryTimer,
 *      and when that goes off, the FSM with start an outbound connection and
 *      change to Connect state.  SO, it looks as though passive connect may
 *      not be that passive... or the RFC fails to fully deal with the
 *      PassiveTcpEstablishment option.
 *
 *      This code TODO
 *
 *
 *
 *   4. bgp_fsOpenSent
 *
 *      Waiting for an OPEN message to roll up.  When it does, do any
 *      collision resolution and either proceed to send KEEPALIVE and change
 *      to OpenConfirm, or proceed to drop connection and change to fsIdle
 *      "comatose".
 *
 *      See...  for notes on collision resolution  TODO
 *
 *   5. bgp_fsOpenConfirm
 *
 *      Waiting for KEEPALIVE message to confirm all is well.
 *
 *      Only one connection for a session can reach fsOpenConfirm -- though
 *      that session can be dumped before it reaches fsEstablished.
 *
 *   6. bgp_fsEstablished
 *
 *      Processing UPDATEs etc.
 *
 *   7. bgp_fsStop
 *
 *      NB: in this state the FSM/Connection is no longer attached to the
 *          parent session.  As far as the BGP Engine and the Routeing Engine
 *          are concerned, the session is over.
 *
 *          The FSM/Connection lingers if a NOTIFICATION is pending being
 *          sent or may be received.
 */
static void bgp_fsm_new_state(bgp_connection connection,
                                                    bgp_fsm_state_t fsm_state) ;
static void bgp_fsm_idle_hold_timer_set(bgp_connection connection) ;
static void bgp_fsm_stop(bgp_connection connection, bgp_fsm_eqb eqb) ;
static void bgp_fsm_exit(bgp_connection connection) ;
static void bgp_fsm_fall_idle(bgp_connection connection, bgp_fsm_eqb eqb,
                                                                    bool damp) ;
static void bgp_fsm_idle_hold_expired(bgp_connection connection) ;
static void bgp_fsm_do_connect(bgp_connection connection) ;
static void bgp_connect_retry_timer_start(bgp_connection connection) ;
static void bgp_fsm_connected(bgp_connection connection) ;
static void bgp_fsm_accepted(bgp_connection connection) ;
static void bgp_fsm_enter_open_confirm(bgp_connection connection) ;
static void bgp_fsm_enter_established(bgp_connection connection) ;

static void bgp_fsm_invalid_event(bgp_connection connection, bgp_fsm_eqb eqb) ;

/*------------------------------------------------------------------------------
 * Handle the given event for the given connection.
 *
 * NB: if the given event includes a NOTIFICATION, we may or may not take
 *     responsibility for it, but if we do will clear the eqb->notif pointer.
 */
static void
bgp_fsm_event_handle(bgp_connection connection, bgp_fsm_event_t fsm_event,
                                                                bgp_fsm_eqb eqb)
{
  bgp_session     session ;
  bgp_fsm_state_t fsm_state_was ;

  session       = connection->session ;         /* currently attached ? */
  fsm_state_was = connection->fsm_state ;

  eqb->fsm_event = fsm_event ;                  /* for completeness     */

  switch (fsm_state_was)
    {
      /* bgp_fsNULL: initialised in this state............................
       *
       * Expect only a eStart event, which arms the IdleHoldTimer and
       * advances to the sIdle state.
       *
       * Could (just) get a bgp_fsm_eStop if gets a stop event before the
       * start event can be processed -- because a stop event is an exception,
       * and can be pushed onto the event queue.
       *
       * A connection should be in this state for a brief period between being
       * initialised and set going.
       *
       * All other events (other than null) are invalid (should not happen).
       */
      case bgp_fsNULL:
        qassert(session != NULL) ;

        switch (fsm_event)
          {
            case bgp_feNULL:
              session = NULL ;                  /* ignore feNULL        */
              break ;

            case bgp_feManualStart:
            case bgp_feAutomaticStart:
            case bgp_feManualStart_with_Passive:
            case bgp_feAutomaticStart_with_Passive:
            case bgp_feAutomaticStart_with_Damp:
            case bgp_feAutomaticStart_with_Damp_and_Passive:
              bgp_fsm_new_state(connection, bgp_fsIdle) ;
              bgp_fsm_idle_hold_timer_set(connection) ;
              break ;

            case bgp_feManualStop:
            case bgp_feAutomaticStop:
              bgp_fsm_stop(connection, eqb) ;
              break ;

            /* Invalid Events for fsNULL
             */
            default:
              qassert(false) ;
              fall_through ;

          //case bgp_feManualStart:
          //case bgp_feManualStop:
          //case bgp_feAutomaticStart:
          //case bgp_feManualStart_with_Passive:
          //case bgp_feAutomaticStart_with_Passive:
          //case bgp_feAutomaticStart_with_Damp:
          //case bgp_feAutomaticStart_with_Damp_and_Passive:
          //case bgp_feAutomaticStop:

            case bgp_feConnectRetryTimer_Expires:
            case bgp_feHoldTimer_Expires:
            case bgp_feKeepaliveTimer_Expires:
            case bgp_feDelayOpenTimer_Expires:
            case bgp_feIdleHoldTimer_Expires:

            case bgp_feTcpConnection_Valid:     // N/A
            case bgp_feTcp_CR_Invalid:          // N/A

            case bgp_feBGPOpen:
            case bgp_feBGPOpen_with_DelayOpenTimer:
            case bgp_feBGPHeaderErr:
            case bgp_feBGPOpenMsgErr:
            case bgp_feOpenCollisionDump:
            case bgp_feNotifyMsgVerErr:
            case bgp_feNotifyMsg:
            case bgp_feKeepAliveMsg:
            case bgp_feUpdateMsg:
            case bgp_feUpdateMsgErr:

            case bgp_feConnected:
            case bgp_feAccepted:
            case bgp_feDown:

            case bgp_feError:
            case bgp_feConnectFailed:

            case bgp_feAcceptOPEN:

            case bgp_feRestart:
            case bgp_feShut_RD:
            case bgp_feShut_WR:

            case bgp_feRRMsg:
            case bgp_feRRMsgErr:

            case bgp_feUnexpected:
            case bgp_feInvalid:

            case bgp_feIO:
              bgp_fsm_invalid_event(connection, eqb) ;
              break ;
          } ;

      /* bgp_fsIdle: waiting for IdleHoldTimer and/or I/O to complete........
       * bgp_fsStop: waiting for I/O to complete
       *
       * NB: in fsIdle we are attached to a session, in fsStop we are not.
       */
      case bgp_fsIdle:
      case bgp_fsStop:
        switch (fsm_event)
          {
            case bgp_feNULL:
              session = NULL ;                  /* ignore feNULL        */
              break ;

            case bgp_feManualStop:
            case bgp_feAutomaticStop:
              bgp_fsm_stop(connection, eqb) ;
              break ;

            case bgp_feRestart:
              break ;                           /* do nothing already   */

            /* The IdleHoldTimer is what we are mostly waiting for.
             *
             * We bgp_fsm_timer_stop() to clear the bfts_expired state.
             */
            case bgp_feIdleHoldTimer_Expires:
              if (connection->fsm_state == bgp_fsIdle)
                bgp_fsm_idle_hold_expired(connection) ;
              else
                bgp_fsm_exit(connection) ;
              break ;

            /* We are not interested in most events for valid messages.
             *
             * There is no point logging these, since they are just a hang-over
             * from whatever state we were in before we fell idle.
             *
             * These might have been rejected in the previous state, but we
             * don't bother with such niceties now.
             */
            case bgp_feBGPOpen:
            case bgp_feBGPOpen_with_DelayOpenTimer:
            case bgp_feUpdateMsg:
            case bgp_feRRMsg:
            case bgp_feKeepAliveMsg:
              session = NULL ;          /* ignore redundant events      */
              break ;

            /* These I/O and message events will have affected the io_state
             * of the connection.
             *
             * If the connection is still up in any way at all, will continue
             * to wait on the current hold timer.
             */
            case bgp_feNotifyMsg:
            case bgp_feNotifyMsgVerErr:
            case bgp_feBGPHeaderErr:
            case bgp_feBGPOpenMsgErr:
            case bgp_feUpdateMsgErr:
            case bgp_feRRMsgErr:
            case bgp_feError:
            case bgp_feDown:
            case bgp_feShut_RD:
            case bgp_feShut_WR:
              qassert(connection->idling_state == bgp_fisIO) ;

              if (connection->io_state == qfDown)
                {
                  if (connection->fsm_state == bgp_fsIdle)
                    bgp_connection_down(connection) ;
                  else
                    bgp_fsm_exit(connection) ;
                } ;
              break ;

             /* Invalid Events for fsIdle
             */
            default:
              qassert(false) ;
              fall_through ;

            case bgp_feManualStart:
          //case bgp_feManualStop:
            case bgp_feAutomaticStart:
            case bgp_feManualStart_with_Passive:
            case bgp_feAutomaticStart_with_Passive:
            case bgp_feAutomaticStart_with_Damp:
            case bgp_feAutomaticStart_with_Damp_and_Passive:
          //case bgp_feAutomaticStop:

            case bgp_feConnectRetryTimer_Expires:
            case bgp_feHoldTimer_Expires:
            case bgp_feKeepaliveTimer_Expires:
            case bgp_feDelayOpenTimer_Expires:
          //case bgp_feIdleHoldTimer_Expires:

            case bgp_feTcpConnection_Valid:     // N/A
            case bgp_feTcp_CR_Invalid:          // N/A

          //case bgp_feBGPOpen:
          //case bgp_feBGPOpen_with_DelayOpenTimer:
          //case bgp_feBGPHeaderErr:
          //case bgp_feBGPOpenMsgErr:
            case bgp_feOpenCollisionDump:
          //case bgp_feNotifyMsgVerErr:
          //case bgp_feNotifyMsg:
          //case bgp_feKeepAliveMsg:
          //case bgp_feUpdateMsg:
          //case bgp_feUpdateMsgErr:

            case bgp_feConnected:
            case bgp_feAccepted:
          //case bgp_feDown:

          //case bgp_feError:
            case bgp_feConnectFailed:

            case bgp_feAcceptOPEN:

          //case bgp_feRestart:
          //case bgp_feShut_RD:
          //case bgp_feShut_WR:

          //case bgp_feRRMsg:
          //case bgp_feRRMsgErr:

            case bgp_feUnexpected:
            case bgp_feInvalid:

            case bgp_feIO:
              bgp_fsm_invalid_event(connection, eqb) ;
              break ;
          } ;
        break ;

      /* bgp_fsConnect: waiting for connect()...................................
       *
       * Only the bc_connect connection can be in this state.
       */
      case bgp_fsConnect:
        qassert(session != NULL) ;
        qassert(connection->ord == bc_connect) ;

        switch (fsm_event)
          {
            case bgp_feNULL:
              session = NULL ;                  /* ignore feNULL        */
              break ;

            case bgp_feManualStop:
            case bgp_feAutomaticStop:
              bgp_fsm_stop(connection, eqb) ;
              break ;

            /* While in fsConnect we are waiting for:
             *
             *   * an outstanding connect() to complete successfully
             *
             *   * an outstanding connect() to fail in some way
             *
             *     Note that per RFC4271, we restart the ConnectRetryTimer
             *     after a failure.
             *
             *     Generally, if the connect() fails it will do so almost
             *     instantly.  So restarting the timer means that will try a
             *     new connection every 120 secs or so.
             *
             *     If the connect() fails after a while, then we assume that
             *     can get the SYN away, so has failed for some reason after
             *     that, perhaps:
             *
             *       a) the connect() timed out -- but we suppress ETIMEDOUT
             *          so that this does not disturb things.
             *
             *       b) the other end took a while to respond with a RST.
             *
             *       c) ....
             *
             *     So... it seems we suppose that the delay in failing the
             *     connect() is caused by the far end, so we restart the
             *     timer from that point on.
             *
             *   * the ConnectRetryTimer to expire.
             */
            case bgp_feConnected:
              bgp_fsm_connected(connection) ;
              break ;

            case bgp_feRestart:
            case bgp_feError:
            case bgp_feConnectFailed:
              bgp_connection_down(connection) ;
              bgp_connect_retry_timer_start(connection) ;
              break ;

            case bgp_feConnectRetryTimer_Expires:
              bgp_fsm_do_connect(connection) ;
              break ;

            /* Invalid Events for fsConnect
             */
            default:
              qassert(false) ;
              fall_through ;

            case bgp_feManualStart:
          //case bgp_feManualStop:
            case bgp_feAutomaticStart:
            case bgp_feManualStart_with_Passive:
            case bgp_feAutomaticStart_with_Passive:
            case bgp_feAutomaticStart_with_Damp:
            case bgp_feAutomaticStart_with_Damp_and_Passive:
          //case bgp_feAutomaticStop:

          //case bgp_feConnectRetryTimer_Expires:
            case bgp_feHoldTimer_Expires:
            case bgp_feKeepaliveTimer_Expires:
            case bgp_feDelayOpenTimer_Expires:
            case bgp_feIdleHoldTimer_Expires:

            case bgp_feTcpConnection_Valid:     // N/A
            case bgp_feTcp_CR_Invalid:          // N/A

            case bgp_feBGPOpen:
            case bgp_feBGPOpen_with_DelayOpenTimer:
            case bgp_feBGPHeaderErr:
            case bgp_feBGPOpenMsgErr:
            case bgp_feOpenCollisionDump:
            case bgp_feNotifyMsgVerErr:
            case bgp_feNotifyMsg:
            case bgp_feKeepAliveMsg:
            case bgp_feUpdateMsg:
            case bgp_feUpdateMsgErr:

          //case bgp_feConnected:
            case bgp_feAccepted:
            case bgp_feDown:

          //case bgp_feError:
          //case bgp_feConnectFailed:

            case bgp_feAcceptOPEN:

          //case bgp_feRestart:
            case bgp_feShut_RD:
            case bgp_feShut_WR:

            case bgp_feRRMsg:
            case bgp_feRRMsgErr:

            case bgp_feUnexpected:
            case bgp_feInvalid:

            case bgp_feIO:
              bgp_fsm_invalid_event(connection, eqb) ;
              break ;
          } ;
        break ;

      /* bgp_fsActive: waiting for listen (only)...............................
       *
       * Only the bc_accept connection can be in this state.
       */
      case bgp_fsActive:
        qassert(session != NULL) ;
        qassert(connection->ord == bc_accept) ;

        switch (fsm_event)
          {
            case bgp_feNULL:
              session = NULL ;                  /* ignore feNULL        */
              break ;

            case bgp_feManualStop:
            case bgp_feAutomaticStop:
              bgp_fsm_stop(connection, eqb) ;
              break ;

            case bgp_feRestart:


            /* We are waiting for the acceptor to deliver an accepted
             * connection.
             */
            case bgp_feAccepted:
            case bgp_feAcceptOPEN:
              bgp_fsm_accepted(connection) ;
              break ;

            /* Invalid Events for fsActive
             */
            default:
              qassert(false) ;
              fall_through ;

            case bgp_feManualStart:
          //case bgp_feManualStop:
            case bgp_feAutomaticStart:
            case bgp_feManualStart_with_Passive:
            case bgp_feAutomaticStart_with_Passive:
            case bgp_feAutomaticStart_with_Damp:
            case bgp_feAutomaticStart_with_Damp_and_Passive:
          //case bgp_feAutomaticStop:

            case bgp_feConnectRetryTimer_Expires:
            case bgp_feHoldTimer_Expires:
            case bgp_feKeepaliveTimer_Expires:
            case bgp_feDelayOpenTimer_Expires:
            case bgp_feIdleHoldTimer_Expires:

            case bgp_feTcpConnection_Valid:     // N/A
            case bgp_feTcp_CR_Invalid:          // N/A

            case bgp_feBGPOpen:
            case bgp_feBGPOpen_with_DelayOpenTimer:
            case bgp_feBGPHeaderErr:
            case bgp_feBGPOpenMsgErr:
            case bgp_feOpenCollisionDump:
            case bgp_feNotifyMsgVerErr:
            case bgp_feNotifyMsg:
            case bgp_feKeepAliveMsg:
            case bgp_feUpdateMsg:
            case bgp_feUpdateMsgErr:

            case bgp_feConnected:
          //case bgp_feAccepted:
            case bgp_feDown:

            case bgp_feError:
            case bgp_feConnectFailed:

          //case bgp_feAcceptOPEN:

          //case bgp_feRestart:
            case bgp_feShut_RD:
            case bgp_feShut_WR:

            case bgp_feRRMsg:
            case bgp_feRRMsgErr:

            case bgp_feUnexpected:
            case bgp_feInvalid:

            case bgp_feIO:
              bgp_fsm_invalid_event(connection, eqb) ;
              break ;
          } ;
        break ;

      /* bgp_fsOpenSent: waiting for OPEN from the other end....................
       *
       * Both bc_connect and bc_accept connections can be in this state.
       *
       * While in this state is waiting for a BGP OPEN to arrive or for the
       * OpenHoldTimer ("large" value) to expire.
       */
      case bgp_fsOpenSent:
        qassert(session != NULL) ;

        switch (fsm_event)
          {
            case bgp_feNULL:
              session = NULL ;                  /* ignore feNULL        */
              break ;

            case bgp_feManualStop:
            case bgp_feAutomaticStop:
              bgp_fsm_stop(connection, eqb) ;
              break ;

            /* We are hoping for an OPEN
             */
            case bgp_feBGPOpen:
            case bgp_feBGPOpen_with_DelayOpenTimer:
              bgp_fsm_enter_open_confirm(connection) ;
              break ;

            /* But if the (long) HoldTimer expires, give-up and fall back
             * to fsIdle.
             */
            case bgp_feHoldTimer_Expires:
              bgp_fsm_timer_stop(connection->hold_timer) ;      /* tidy */

              eqb->note = bgp_note_set(eqb->note,
                                       BGP_NOMC_HOLD_EXP, BGP_NOMS_UNSPECIFIC) ;
              bgp_fsm_fall_idle(connection, eqb, true /* damp */) ;
              break ;

            /* Sibling won the collision resolution when we tried to move up
             * to fsOpenConfirm :-(
             *
             * Note that the priority of the feOpenCollisionDump is such that
             * nothing other than feManualStop or feAutomaticStop can happen
             * while this event was pending... so cannot go fsOpenConfirm !
             */
            case bgp_feOpenCollisionDump:
              bgp_fsm_fall_idle(connection, eqb, false /* no damp */) ;
              break ;

            /* If we get a NOTIFICATION, we fall back, too.
             *
             * But if is BGP_NOMC_OPEN/BGP_NOMS_O_OPTION, set cap_suppress, so
             * that next time we try without.
             */
            case bgp_feNotifyMsgVerErr:
            case bgp_feNotifyMsg:
              qassert(eqb->note != NULL) ;

              if (eqb->note != NULL)
                {
                  if ( (eqb->note->code    == BGP_NOMC_OPEN) &&
                       (eqb->note->subcode == BGP_NOMS_O_OPTION) )
                    connection->cap_suppress = true ;
                } ;
              fall_through ;

            /* If we get a NOTIFICATION, we fall back, too.
             *
             * If we get an I/O error or the connection is closed, fall back.
             */
            case bgp_feError:
            case bgp_feDown:
            case bgp_feRestart:
            case bgp_feShut_RD:
            case bgp_feShut_WR:
              bgp_fsm_fall_idle(connection, eqb, true /* damp */) ;
              break ;

            /* All these are (wholely) unexpected !
             *
             * ...but may come with a more specific NOTIFICATION !
             */
            case bgp_feKeepAliveMsg:
            case bgp_feUpdateMsg:
            case bgp_feRRMsg:
              eqb->note = bgp_note_default(eqb->note,
                                        BGP_NOMC_FSM, BGP_NOMS_F_IN_OPEN_SENT) ;
              bgp_fsm_fall_idle(connection, eqb, true /* damp */) ;
              break ;

            /* If message level errors do not carry a specific NOTIFICATION,
             * drop in an unspecific one.
             */
            case bgp_feBGPHeaderErr:
            case bgp_feUpdateMsgErr:
            case bgp_feRRMsgErr:
              eqb->note = bgp_note_default(eqb->note,
                                          BGP_NOMC_CEASE, BGP_NOMS_UNSPECIFIC) ;
              bgp_fsm_fall_idle(connection, eqb, true /* damp */) ;
              break ;

            /* Invalid Events for fsOpenSent
             */
            default:
              qassert(false) ;
              fall_through ;

            case bgp_feManualStart:
          //case bgp_feManualStop:
            case bgp_feAutomaticStart:
            case bgp_feManualStart_with_Passive:
            case bgp_feAutomaticStart_with_Passive:
            case bgp_feAutomaticStart_with_Damp:
            case bgp_feAutomaticStart_with_Damp_and_Passive:
          //case bgp_feAutomaticStop:

            case bgp_feConnectRetryTimer_Expires:
          //case bgp_feHoldTimer_Expires:
            case bgp_feKeepaliveTimer_Expires:
            case bgp_feDelayOpenTimer_Expires:
            case bgp_feIdleHoldTimer_Expires:

            case bgp_feTcpConnection_Valid:     // N/A
            case bgp_feTcp_CR_Invalid:          // N/A

          //case bgp_feBGPOpen:
          //case bgp_feBGPOpen_with_DelayOpenTimer:
          //case bgp_feBGPHeaderErr:
          //case bgp_feBGPOpenMsgErr:
          //case bgp_feOpenCollisionDump:
          //case bgp_feNotifyMsgVerErr:
          //case bgp_feNotifyMsg:
          //case bgp_feKeepAliveMsg:
          //case bgp_feUpdateMsg:
          //case bgp_feUpdateMsgErr:

            case bgp_feConnected:
            case bgp_feAccepted:
          //case bgp_feDown:

          //case bgp_feError:
            case bgp_feConnectFailed:

            case bgp_feAcceptOPEN:

          //case bgp_feRestart:
          //case bgp_feShut_RD:
          //case bgp_feShut_WR:

          //case bgp_feRRMsg:
          //case bgp_feRRMsgErr:

            case bgp_feUnexpected:
            case bgp_feInvalid:

            case bgp_feIO:
              bgp_fsm_invalid_event(connection, eqb) ;
              break ;
          } ;
        break ;

      /* bgp_fsOpenConfirm: Opens sent and received, waiting for KeepAlive.....
       *
       * Only one of the two connections can reach this state.
       *
       * While in this state is waiting for a KEEPALIVE to arrive or for the
       * HoldTimer to expire, or for the KeepaliveTimer to prompt sending of
       * another KEEPALIVE message.
       *
       * Notes:
       *
       *   * feKeepAliveMsg -- effectively 'ACK' for OPEN.
       */
      case bgp_fsOpenConfirm:
        qassert(session != NULL) ;

        switch (fsm_event)
          {
            case bgp_feNULL:
              session = NULL ;                  /* ignore feNULL        */
              break ;

            case bgp_feManualStop:
            case bgp_feAutomaticStop:
              bgp_fsm_stop(connection, eqb) ;
              break ;

            /* We are waiting for a KEEPALIVE to confirm that the session is,
             * finally, established.
             */
            case bgp_feKeepAliveMsg:
              bgp_fsm_enter_established(connection) ;
              break ;

            /* Sibling won the collision resolution and pushes us out of
             * fsOpenConfirm :-(
             *
             * For a brief period, we and our sibling shared fsOpenConfirm,
             * but that is all over, now.  Note that the priority of the
             * the feOpenCollisionDump is such that nothing other than
             * feManualStop or feAutomaticStop can happen while we are in the
             * super-imposed state... so cannot go fsEstablished !
             */
            case bgp_feOpenCollisionDump:
              bgp_fsm_fall_idle(connection, eqb, false /* no damp */) ;
              break ;

            /* In fsOpenConfirm we keep sending KEEPALIVES.
             */
            case bgp_feKeepaliveTimer_Expires:
              bgp_fsm_timer_stop(connection->keepalive_timer) ; /* tidy */

              bgp_msg_write_keepalive(connection, false /* optional */) ;

              session = NULL ;                  /* do not report        */
              break ;

            /* But if the HoldTimer expires, it is all for nought.
             */
            case bgp_feHoldTimer_Expires:
              bgp_fsm_timer_stop(connection->hold_timer) ;      /* tidy */

              eqb->note = bgp_note_set(eqb->note,
                                       BGP_NOMC_HOLD_EXP, BGP_NOMS_UNSPECIFIC) ;
              bgp_fsm_fall_idle(connection, eqb, true /* damp */) ;
              break ;

            /* If we get a NOTIFICATION, we fall back, too.
             *
             * If we get an I/O error or the connection is closed, fall back.
             */
            case bgp_feNotifyMsgVerErr:
            case bgp_feNotifyMsg:
            case bgp_feError:
            case bgp_feDown:
            case bgp_feRestart:
            case bgp_feShut_RD:
            case bgp_feShut_WR:
              bgp_fsm_fall_idle(connection, eqb, true /* damp */) ;
              break ;

            /* All these are (wholely) unexpected !
             *
             * ...but may come with a more specific NOTIFICATION !
             */
            case bgp_feBGPOpen:
            case bgp_feBGPOpen_with_DelayOpenTimer:
            case bgp_feUpdateMsg:
            case bgp_feRRMsg:
              eqb->note = bgp_note_default(eqb->note,
                                        BGP_NOMC_FSM, BGP_NOMS_F_IN_OPEN_SENT) ;
              bgp_fsm_fall_idle(connection, eqb, true /* damp */) ;
              break ;

            /* If message level errors do not carry a specific NOTIFICATION,
             * drop in an unspecific one.
             */
            case bgp_feBGPHeaderErr:
            case bgp_feUpdateMsgErr:
            case bgp_feRRMsgErr:
              eqb->note = bgp_note_default(eqb->note,
                                          BGP_NOMC_CEASE, BGP_NOMS_UNSPECIFIC) ;
              bgp_fsm_fall_idle(connection, eqb, true /* damp */) ;
              break ;

            /* Invalid Events for fsOpenConfirm
             */
            default:
              qassert(false) ;
              fall_through ;

            case bgp_feManualStart:
          //case bgp_feManualStop:
            case bgp_feAutomaticStart:
            case bgp_feManualStart_with_Passive:
            case bgp_feAutomaticStart_with_Passive:
            case bgp_feAutomaticStart_with_Damp:
            case bgp_feAutomaticStart_with_Damp_and_Passive:
          //case bgp_feAutomaticStop:

            case bgp_feConnectRetryTimer_Expires:
          //case bgp_feHoldTimer_Expires:
          //case bgp_feKeepaliveTimer_Expires:
            case bgp_feDelayOpenTimer_Expires:
            case bgp_feIdleHoldTimer_Expires:

            case bgp_feTcpConnection_Valid:     // N/A
            case bgp_feTcp_CR_Invalid:          // N/A

          //case bgp_feBGPOpen:
          //case bgp_feBGPOpen_with_DelayOpenTimer:
          //case bgp_feBGPHeaderErr:
          //case bgp_feBGPOpenMsgErr:
          //case bgp_feOpenCollisionDump:
          //case bgp_feNotifyMsgVerErr:
          //case bgp_feNotifyMsg:
          //case bgp_feKeepAliveMsg:
          //case bgp_feUpdateMsg:
          //case bgp_feUpdateMsgErr:

            case bgp_feConnected:
            case bgp_feAccepted:
          //case bgp_feDown:

          //case bgp_feError:
            case bgp_feConnectFailed:

            case bgp_feAcceptOPEN:

          //case bgp_feRestart:
          //case bgp_feShut_RD:
          //case bgp_feShut_WR:

          //case bgp_feRRMsg:
          //case bgp_feRRMsgErr:

            case bgp_feUnexpected:
            case bgp_feInvalid:

            case bgp_feIO:
              bgp_fsm_invalid_event(connection, eqb) ;
              break ;
          } ;
        break ;

      /* bgp_fsEstablished: session is up and running..........................
       *
       * Only the primary connection exists in this state.
       *
       * While in this state is waiting for UPDATE or ROUTE_REFRESH
       * (or KEEPALIVE) messages to arrive or for the HoldTimer to expire, or for
       * the KeepaliveTimer to prompt sending of another KEEPALIVE message.
       *
       * Notes:
       *
       *   * eUPDATE_in -- the real business
       *
       *     In fact this is dealt with elsewhere, to avoid going through the
       *     full FSM process -- see above.
       *
       *     This also applies to ROUTE_REFRESH messages.
       */
      case bgp_fsEstablished:
        qassert(session != NULL) ;

        switch (fsm_event)
          {
            case bgp_feNULL:
              session = NULL ;                  /* ignore feNULL        */
              break ;

            /* If Stop events do not carry a NOTIFICATION, it is assumed
             * that is deliberate.
             */
            case bgp_feManualStop:
            case bgp_feAutomaticStop:
            case bgp_feRestart:
              bgp_fsm_stop(connection, eqb) ;
              break ;

            /* We are expecting UPDATE, ROUTE_REFRESH and KEEPALIVE messages,
             * so much so that those are all dealt with directly as part of
             * the feIO event -- without raising the specific message events.
             */
            case bgp_feUpdateMsg:
            case bgp_feRRMsg:
            case bgp_feKeepAliveMsg:
              bgp_fsm_invalid_event(connection, eqb) ;
              break ;

            /* We also expect to dosh out KEEPALIVE messages on a regular
             * basis.
             */
            case bgp_feKeepaliveTimer_Expires:
              bgp_fsm_timer_stop(connection->keepalive_timer) ; /* tidy */

              bgp_msg_write_keepalive(connection, false /* optional */) ;

              session = NULL ;                  /* do not report        */
              break ;

            /* If the HoldTimer expires, we have to stop !
             */
            case bgp_feHoldTimer_Expires:
              bgp_fsm_timer_stop(connection->hold_timer) ;      /* tidy */

              eqb->note = bgp_note_set(eqb->note,
                                       BGP_NOMC_HOLD_EXP, BGP_NOMS_UNSPECIFIC) ;
              bgp_fsm_stop(connection, eqb) ;
              break ;

            /* If we get a NOTIFICATION, we stop, too.
             *
             * If we get an I/O error or the connection is closed, stop.
             */
            case bgp_feNotifyMsg:
            case bgp_feNotifyMsgVerErr:
            case bgp_feError:
            case bgp_feDown:
            case bgp_feShut_RD:
            case bgp_feShut_WR:
              bgp_fsm_stop(connection, eqb) ;
              break ;

            /* Anything to do with OPEN is (wholely) unexpected !
             *
             * ...but may come with a more specific NOTIFICATION !
             */
            case bgp_feBGPOpen:
            case bgp_feBGPOpen_with_DelayOpenTimer:
            case bgp_feBGPOpenMsgErr:
              eqb->note = bgp_note_default(eqb->note,
                                      BGP_NOMC_FSM, BGP_NOMS_F_IN_ESTABLISHED) ;
              bgp_fsm_stop(connection, eqb) ;
              break ;

            /* If message level errors do not carry a specific NOTIFICATION,
             * drop in an unspecific one.
             */
            case bgp_feBGPHeaderErr:
            case bgp_feUpdateMsgErr:
            case bgp_feRRMsgErr:
              eqb->note = bgp_note_default(eqb->note,
                                          BGP_NOMC_CEASE, BGP_NOMS_UNSPECIFIC) ;
              bgp_fsm_stop(connection, eqb) ;
              break ;

            /* Invalid Events for fsEstablished
             */
            default:
              qassert(false) ;
              fall_through ;

            case bgp_feManualStart:
          //case bgp_feManualStop:
            case bgp_feAutomaticStart:
            case bgp_feManualStart_with_Passive:
            case bgp_feAutomaticStart_with_Passive:
            case bgp_feAutomaticStart_with_Damp:
            case bgp_feAutomaticStart_with_Damp_and_Passive:
          //case bgp_feAutomaticStop:

            case bgp_feConnectRetryTimer_Expires:
          //case bgp_feHoldTimer_Expires:
          //case bgp_feKeepaliveTimer_Expires:
            case bgp_feDelayOpenTimer_Expires:
            case bgp_feIdleHoldTimer_Expires:

            case bgp_feTcpConnection_Valid:     // N/A
            case bgp_feTcp_CR_Invalid:          // N/A

          //case bgp_feBGPOpen:
          //case bgp_feBGPOpen_with_DelayOpenTimer:
          //case bgp_feBGPHeaderErr:
          //case bgp_feBGPOpenMsgErr:
            case bgp_feOpenCollisionDump:
          //case bgp_feNotifyMsgVerErr:
          //case bgp_feNotifyMsg:
          //case bgp_feKeepAliveMsg:
          //case bgp_feUpdateMsg:
          //case bgp_feUpdateMsgErr:

            case bgp_feConnected:
            case bgp_feAccepted:
          //case bgp_feDown:

          //case bgp_feError:
            case bgp_feConnectFailed:

            case bgp_feAcceptOPEN:

          //case bgp_feRestart:
          //case bgp_feShut_RD:
          //case bgp_feShut_WR:

          //case bgp_feRRMsg:
          //case bgp_feRRMsgErr:

            case bgp_feUnexpected:
            case bgp_feInvalid:

            case bgp_feIO:
              bgp_fsm_invalid_event(connection, eqb) ;
              break ;
          } ;
        break ;

      /* unknown state: should not be here...................................
       */
      default:
        qassert(false) ;

        bgp_fsm_invalid_event(connection, eqb) ;
        break ;
    } ;

  /* Log what happened as required.
   */
  if (BGP_DEBUG(fsm, FSM) && (fsm_event != bgp_feNULL))
    plog_debug(connection->lox.log, "%s [FSM] event %s (%s->%s)",
                    connection->lox.name,
                    map_direct(bgp_fsm_event_map, fsm_event).str,
                    map_direct(bgp_fsm_state_map, fsm_state_was).str,
                    map_direct(bgp_fsm_state_map, connection->fsm_state).str) ;
  else if (BGP_DEBUG(normal, NORMAL) && (fsm_event != bgp_feNULL))
    plog_debug (connection->lox.log, "%s on %s FSM went from %s to %s",
                  connection->lox.name,
                  map_direct(bgp_fsm_event_map, fsm_event).str,
                  map_direct(bgp_fsm_state_map, fsm_state_was).str,
                  map_direct(bgp_fsm_state_map, connection->fsm_state).str) ;

  /* Report what happened to the Routeing Engine, via the session was
   * connected to, if any.
   *
   * NB: in some cases we don't wish to report the event, and in those we
   *     set session = NULL, above...  dirty but effective.
   */
  if (session != NULL)
    {
      if (connection->session == NULL)
        qassert(session->connections[connection->ord] == NULL) ;
      else
        qassert( (connection->session == session)
              && (session->connections[connection->ord] == connection) ) ;

      bgp_session_send_event(session, connection->ord, eqb) ;

      if (bgp_dump_state_flag)
        bgp_dump_state (session, connection->fsm_state, fsm_state_was) ;
    } ;
} ;

/*------------------------------------------------------------------------------
 * Set a new connection->state.
 *
 * Do some tidying up of timers and meta-events.
 */
static void
bgp_fsm_new_state(bgp_connection connection, bgp_fsm_state_t fsm_state)
{
  if (connection->fsm_state == fsm_state)
    return ;

  switch (fsm_state)
    {
      case bgp_fsNULL:
        break ;

      /* We can fall back to fsIdle from most states.
       *
       * Can arrive in fsIdle from fsNULL, and the tidying up will be moot.
       *
       * Stops both timers -- KeepaliveTimer runs in fsOpenConfirm.
       *
       * Discards any fmSocket events.   On entry to fsActive will
       * re-interrogate the acceptor.
       */
      case bgp_fsIdle:
        qassert(connection->fsm_state != bgp_fsEstablished) ;
        qassert(connection->fsm_state != bgp_fsStop) ;

        connection->meta_events &= ~(bgp_fmKeepaliveTimer       |
                                     bgp_fmHoldTimer            |
                                     bgp_fmSocket) ;
        bgp_fsm_timer_stop(connection->hold_timer) ;
        bgp_fsm_timer_stop(connection->keepalive_timer) ;
        break ;

      /* Enters fsConnect from fsIdle, when IdleHoldTimer expires.
       * Enters fsActive ditto
       */
      case bgp_fsConnect:
      case bgp_fsActive:
        qassert(connection->fsm_state == bgp_fsIdle) ;
        qassert(!(connection->meta_events & (bgp_fmKeepaliveTimer       |
                                             bgp_fmHoldTimer            |
                                             bgp_fmSocket))) ;
        qassert(connection->hold_timer->state      == bfts_stopped) ;
        qassert(connection->keepalive_timer->state == bfts_stopped) ;
        break ;

      /* Enters fsOpenSent from fsConnect or fsActive.
       *
       * We stop the hold_timer -- which may be the ConnectRetryTimer or the
       * DelayOpenTimer.
       *
       * But we may inherit bgp_fmTCP_Accepted and/or bgp_fmAccepted_OPEN
       */
      case bgp_fsOpenSent:
        qassert( (connection->fsm_state == bgp_fsConnect) ||
                 (connection->fsm_state == bgp_fsActive) ) ;

        qassert(!(connection->meta_events & (bgp_fmKeepaliveTimer))) ;
        qassert(connection->keepalive_timer->state == bfts_stopped) ;

        bgp_fsm_timer_stop(connection->hold_timer) ;
        break ;

      /* Enters fsOpenConfirm from fsOpenSent.
       *
       * Stops and will restart the HoldTimer.
       *
       * May inherit bgp_fmTCP_Accepted and/or bgp_fmAccepted_OPEN
       */
      case bgp_fsOpenConfirm:
        qassert(connection->fsm_state == bgp_fsOpenSent) ;

        qassert(!(connection->meta_events & (bgp_fmKeepaliveTimer))) ;
        qassert(connection->keepalive_timer->state == bfts_stopped) ;

        bgp_fsm_timer_stop(connection->hold_timer) ;
        break ;

      /* Enters fsEstablished from fsOpenConfirm.
       *
       * Stops and will restart the HoldTimer.
       * Inherits the KeepaliveTimer.
       *
       * May inherit bgp_fmTCP_Accepted and/or bgp_fmAccepted_OPEN
       */
      case bgp_fsEstablished:
        qassert(connection->fsm_state == bgp_fsOpenSent) ;

        qassert(connection->hold_timer->state      != bfts_stopped) ;
        qassert(connection->keepalive_timer->state != bfts_stopped) ;

        bgp_fsm_timer_stop(connection->hold_timer) ;
        break ;

      /* If we don't recognise the state... force bgp_fsStop !!
       */
      default:
        fsm_state = bgp_fsStop ;

        fall_through ;

      /* We can go fsStop from all states.
       *
       * Can (just) arrive in fsStop from fsNULL, and the tidying up will be
       * moot.
       *
       * Can arrive from fsIdle... which will preserve all state.
       *
       * From all other states, will stop timers and discard any pending
       * acceptor events.
       */
      case bgp_fsStop:
        if (connection->fsm_state != bgp_fsIdle)
          {
            connection->meta_events &= ~(bgp_fmKeepaliveTimer       |
                                         bgp_fmHoldTimer            |
                                         bgp_fmSocket) ;
            bgp_fsm_timer_stop(connection->hold_timer) ;
            bgp_fsm_timer_stop(connection->keepalive_timer) ;
          } ;
        break ;
    } ;

  connection->fsm_state = fsm_state ;
} ;

/*==============================================================================
 * The BGP FSM Action Functions
 */
static void bgp_fsm_enter_stop(bgp_connection connection) ;
static void bgp_fsm_leave_established(bgp_connection connection,
                                                        bgp_fsm_eqb eqb) ;
static void bgp_fsm_complete(bgp_connection connection, bgp_fsm_eqb eqb) ;
static void bgp_fsm_enter_open_sent(bgp_connection connection) ;

static void bgp_fsm_idle_hold_timer_set_interval(bgp_connection connection,
                                                            qtime_t interval) ;
static qtime_t bgp_fsm_idle_hold_time_update(bgp_connection connection,
                                                                    bool damp) ;
static void bgp_fsm_open_hold_timer_set(bgp_connection connection) ;
static void bgp_fsm_hold_timer_set(bgp_connection connection) ;
static void bgp_fsm_keepalive_timer_set(bgp_connection connection) ;

/*------------------------------------------------------------------------------
 * Bring connection to a stop -- sending any notification in the process.
 *
 * Used for feManualStop and feAutomaticStop, and also for any failure in
 * fsEstablished and FSM errors elsewhere.
 *
 * We may arrive here from any (known) state.
 *
 * If already fsStop this is the same as bgp_fsm_exit().
 *
 * If is fsEstablished, then tidies up the ring-buffer stuff and ... XXX XXX
 *
 * Severs connection with session, and pushes connection into fsStop.  The
 * connection may already have been cut loose... which happens to the sibling
 * of the connection which achieves sEstablished.
 *
 * Stops timers (except for hold_timer, if currently fsIdle).
 *
 * NB: if is fsIdle, then there may be a notification already in progress.
 *
 * NB: can go from fsNULL to fsStop and stopping !
 */
static void
bgp_fsm_stop(bgp_connection connection, bgp_fsm_eqb eqb)
{
  bool was_idle ;

  /* bgp_fsm_stop() is pretty general purpose, so we end up examining the
   * state again.
   */
  switch (connection->fsm_state)
    {
      /* Going from fsIdle to fsStop is a little special.
       */
      case bgp_fsIdle:
        was_idle = true ;
        break ;

      /* Most other states are "not-idle"
       */
      case bgp_fsConnect:
      case bgp_fsActive:
      case bgp_fsOpenSent:
      case bgp_fsOpenConfirm:
        was_idle = false ;
        break ;

      /* As we leave fsEstablished, MUST tidy up buffer handling and the like.
       *
       * Also, wasn't fsIdle.
       */
      case bgp_fsEstablished:
        bgp_fsm_leave_established(connection, eqb) ;

        was_idle = false ;
        break ;

      /* Dunno what's going on here -- force fsStop !
       */
      default:
        qassert(false) ;
        fall_through ;

      /* For Invalid Events we do bgp_fsm_stop(), but if already fsStop we
       * really mean bgp_fsm_exit().
       */
      case bgp_fsStop:
        return bgp_fsm_exit(connection) ;
    } ;

  /* Detach from the session, which may stop the session, and set fsStop.
   *
   * This allows for the case of the sibling which lost the race to
   * sEstablished, which has already been detached from the session !
   */
  bgp_fsm_enter_stop(connection) ;

  /* If was not fsIdle, tell writer that (after any NOTIFICATION) there is
   * nothing more to be written -- shut the writer if buffers are empty (which
   * they won't be if is sending NOTIFICATION).
   */
  if (!was_idle)
    bgp_fsm_complete(connection, eqb) ;

  qassert(connection->io_state != qfUp) ;

  /* Now, if some I/O is still running, if was already idle, then the isIO
   * timer must be running, and we are done.  Otherwise, set that timer.
   *
   * If no I/O is running, it is all over.
   */
  if (connection->io_state != qfDown)
    {
      if (was_idle)
        {
          qassert(connection->idling_state == bgp_fisIO) ;
          qassert( (connection->hold_timer->state == bfts_running) ||
                   (connection->hold_timer->state == bfts_expired) ) ;
        }
      else
        {
          connection->idling_state = bgp_fisIO ;
          bgp_fsm_idle_hold_timer_set_interval(connection, QTIME(IO_Hold_Time));
        } ;

      connection->idle_time_pending = 0 ;       /* tidy         */
    }
  else
    {
      /* It is all over.
       */
      bgp_fsm_exit(connection) ;
    } ;
} ;

/*------------------------------------------------------------------------------
 * Detach connection from session and set fsStop.
 *
 * If not already detached from the session, must detach and if we are the only
 * connection, set the session sStopped.  Note that if we are fsEstablished we
 * are the only connection.
 *
 * If is already detached, then that is most likely because is the victim of
 * fratricide... the sibling won the race to sEstablished.
 *
 * NB: if there is a sibling, then:
 *
 *       * we cannot be fsEstablished and the session cannot be sEstablished...
 *
 *         ...because the winner detaches the loser.
 *
 *       * session must be expected to continue.
 *
 *         This can happen if the accept or the connect connection is
 *         turned off while in sAcquiring state.
 *
 *     In any case, the sibling is now responsible for the session state.
 *
 * NB: the procedure here will cope if is already fsStop, or is in some
 *     other exotic state that we what not of.
 */
static void
bgp_fsm_enter_stop(bgp_connection connection)
{
  bgp_session  session ;

  session = connection->session ;

  if (session != NULL)
    {
      /* Detaching from the session may change its state -- which we worry
       * about now.
       */
      bgp_connection sibling ;

      qassert(connection->fsm_state != bgp_fsStop) ;
      qassert(connection == session->connections[connection->ord]) ;

      /* The usual reasons for stopping a connection are:
       *
       *   a) it is the fsEstabished session, and the session is being brought
       *      down, for some reason.
       *
       *   b) it is the loser in a Collision, and the sibling session has
       *      established itself -- but that cuts loser away from the session
       *      immediately -- so we don't get to here.
       *
       * The unusual reasons are:
       *
       *   c) a Stop event -- when neither connection is established.
       */
      sibling = bgp_connection_get_sibling(connection) ;

      if (sibling != NULL)
        {
          /* There is a sibling -- so neither is fsEstablished
           *
           * So this is likely to be the result of a Stop event, so either
           * the sibling will have been sent the same Stop, or it is
           * intended to continue !  Either way, there is no more to be
           * done.
           */
          qassert(sibling->session == session) ;

          qassert(session->connections[bc_estd] == NULL) ;
          qassert(session->state        != bgp_sEstablished) ;
          qassert(sibling->fsm_state    != bgp_fsEstablished) ;
          qassert(connection->fsm_state != bgp_fsEstablished) ;
        }
      else
        {
          /* No sibling... if we are established, clear that state.
           *
           * In any case, we are now sStopped.
           */
          if (connection == session->connections[bc_estd])
            {
              /* We are the established connection, so we are in charge:
               *
               * Session must be sEstablished and there can be no sibling.
               */
              qassert(session->state        == bgp_sEstablished) ;
              qassert(connection->fsm_state == bgp_fsEstablished) ;
              qassert(sibling == NULL) ;

              session->connections[bc_estd] = NULL ;
            } ;

          session->state = bgp_sStopped ;
        } ;

      /* We can now... detach from the session !
       */
      session->connections[connection->ord] = NULL ;
      connection->session = NULL ;
    } ;

  /* Finally -- go to fsStop.
   */
  bgp_fsm_new_state(connection, bgp_fsStop) ;
} ;

/*------------------------------------------------------------------------------
 * The event we have in our hands is not believed to be valid for the state
 * we are in -- or the state we are in is not valid.
 *
 * We log this as an error, and stop the connection.
 *
 * If the state is not valid, it may be fsStop or complete rubbish.
 *
 * In any case, we go fsStop (or exit) and ensure detached cleanly from any
 * parent session !
 */
static void
bgp_fsm_invalid_event(bgp_connection connection, bgp_fsm_eqb eqb)
{
  if (eqb->note == NULL)
    plog_err(connection->lox.log, "%s [FSM] invalid event %s in state %s",
             connection->lox.name,
             map_direct(bgp_fsm_event_map, eqb->fsm_event).str,
             map_direct(bgp_fsm_state_map, connection->fsm_state).str) ;
  else
    plog_err(connection->lox.log, "%s [FSM] invalid event %s in state %s"
                                                       " with notification %s",
             connection->lox.name,
             map_direct(bgp_fsm_event_map, eqb->fsm_event).str,
             map_direct(bgp_fsm_state_map, connection->fsm_state).str,
             bgp_note_string(eqb->note).str) ;

  /* So STOP !
   */
  eqb->note = bgp_note_default(eqb->note, BGP_NOMC_CEASE, BGP_NOMS_UNSPECIFIC) ;
  bgp_fsm_stop(connection, eqb) ;
} ;

/*------------------------------------------------------------------------------
 * Was stopping and has now successfully stopped -- or crash exit.
 *
 * In the well behaved cases, we arrive here fsIdle + stopping.
 *
 * We may also arrive here if something unexpected has happened, and we do
 * not seem to have a valid state or is stopping but not fsIdle !
 *
 * The main thing is to make sure that when we exit, the session does not have
 * any dangling pointers.  We do that by hand, from first principles -- which
 * does not adversely affect the well behaved cases.
 */
static void
bgp_fsm_exit(bgp_connection connection)
{
  qassert(connection->fsm_state == bgp_fsStop) ;
  qassert(connection->session   == NULL) ;

  /* In case we arrive here in a non-standard state, make sure that we are
   * detached from the session and that we are fsStop before setting curtains.
   *
   * The connection will be terminated, which will deal with any timers, etc.
   */
  bgp_fsm_enter_stop(connection) ;

  connection->meta_events = bgp_fmStop ;        /* all over     */
} ;

/*------------------------------------------------------------------------------
 * Bring connection down to fsIdle -- sending any notification in the process.
 *
 * If there has been an I/O failure or an incoming NOTIFICATION, then the
 * connection will be qfDown and any outbound notification will be ignored.
 *
 * If we initiate a notification, we set the idling_state and the idle_pending
 * as required, and leave the connection csNotify_in/out_pending.  Otherwise,
 * we close the connection and set the simple idle timer.
 *
 * We can fall to idle from any state above fsIdle and below fsEstablished,
 * thus:
 *
 *   fsConnect      -- if is delaying_open or for feOpenCollisionDump
 *   fsActive       -- ditto
 *   fsOpenSent     -- at all times
 *   fsOpenConfirm  -- ditto
 *
 * but excludes fsEstablished, where we stop if something goes wrong.
 */
static void
bgp_fsm_fall_idle(bgp_connection connection, bgp_fsm_eqb eqb, bool damp)
{
  qtime_t idle_hold_time, interval ;

  qassert( (connection->fsm_state == bgp_fsConnect)
        || (connection->fsm_state == bgp_fsActive)
        || (connection->fsm_state == bgp_fsOpenSent)
        || (connection->fsm_state == bgp_fsOpenConfirm) ) ;
  qassert(connection->session != NULL) ;

  /* Enter fsIdle, and apply DampPeerOscillations if required.
   */
  bgp_fsm_new_state(connection, bgp_fsIdle) ;

  idle_hold_time = bgp_fsm_idle_hold_time_update(connection, damp) ;

  /* Tell writer that (after any NOTIFICATION) there is nothing more to be
   * written -- shut the writer if buffers are empty (which won't be if is
   * sending NOTIFICATION).
   *
   * If something is running (is not fDown), set timer for that to complete.
   * (Is probably the NOTIFICATION, but we let any currently buffered stuff
   *  be sent to the system before terminating, and input stuff to be
   *  processed, at least up to a NOTIFICATION.)
   */
  bgp_fsm_complete(connection, eqb) ;

  qassert(connection->io_state != qfUp) ;

  if (connection->io_state != qfDown)
    {
      /* Now worry about the idling state.  The IO_Hold_Time overlaps the
       * start of the IdleHoldTime, but sets a minimum for that.
       *
       * NB: we don't set idle_pending to zero... after the IO_Hold_Time we set
       *     at least the absolute minimum IdleHoldTime -- so that there isn't
       *     a stark difference between an IdleHoldTime exactly the same as the
       *     IO_Hold_Time, and one a smidge bigger !
       */
      connection->idling_state = bgp_fisIO ;

      interval = QTIME(IO_Hold_Time) ;
      if (idle_hold_time > interval)
        connection->idle_time_pending = idle_hold_time - interval ;
      else
        connection->idle_time_pending = 1 ;
    }
  else
    {
      /* Going fsIdle and no more output pending, so we can now down the
       * connection and run the straightforward IdleHoldTime.
       */
      bgp_connection_down(connection) ;

      interval = idle_hold_time ;

      connection->idling_state = bgp_fisHold ;
      connection->idle_time_pending = 0 ;       /* tidy         */
    } ;

  bgp_fsm_idle_hold_timer_set_interval(connection, interval) ;
} ;

/*------------------------------------------------------------------------------
 * "complete" the given connection -- sending any notification in the process.
 *
 * Drops the connection from fUp to fUp_RDWR or lower.
 *
 * If the output has already been shutdown, does nothing.
 *
 * Otherwise, signals to the writer that all writing is complete, after
 * sending any NOTIFICATION we have in hand.
 *
 * NB: if there is a NOTIFICATION to be sent, then if the writer was OK,
 *     it now has that NOTIFICATION in its buffer.
 */
static void
bgp_fsm_complete(bgp_connection connection, bgp_fsm_eqb eqb)
{
  if (connection->io_state & qfUp_WR)
    {
      bgp_note note ;
      bool complete ;

      note = eqb->note ;

      if ((note != NULL) && note->received)
        note = NULL ;

      complete = bgp_msg_write_complete(connection, note) ;

      if (complete)
        bgp_connection_shut_wr(connection) ;
    } ;

  connection->io_state &= qfUp_RDWR ;        /* no longer fUp !      */

  confirm(qfDown    == (qfDown  & qfUp_RDWR)) ;
  confirm(qfUp_RD   == (qfUp_RD & qfUp_RDWR)) ;
  confirm(qfUp_WR   == (qfUp_WR & qfUp_RDWR)) ;
  confirm(qfUp_RDWR == (qfUp    & qfUp_RDWR)) ;
} ;

/*------------------------------------------------------------------------------
 * The IdleHoldTimer has expired -- fsIdle.
  */
static void
bgp_fsm_idle_hold_expired(bgp_connection connection)
{
  bgp_connection sibling ;
  qtime_t continuation ;

  qassert(connection->fsm_state == bgp_fsIdle) ;

  bgp_fsm_timer_stop(connection->hold_timer) ;  /* clear expired state  */

  switch (connection->idling_state)
    {
      default:
        qassert(false) ;
        fall_through ;

      /* The timer is for an extended IdleHoldTime
       */
      case bgp_fisExtended:
        connection->idling_state = bgp_fisNULL ;        /* not fsIdle   */
        continuation = 0 ;                              /* done         */
        break ;

      /* The timer is for ordinary IdleHoldTime
       *
       * We assume we are done here, but worry about sibling if not stopping.
       */
      case bgp_fisHold:
        sibling = bgp_connection_get_sibling(connection) ;

        if ((sibling != NULL) && ( (sibling->fsm_state == bgp_fsOpenSent) ||
                                   (sibling->fsm_state == bgp_fsOpenConfirm) ))
          {
            /* This is a wrinkle.  If have a sibling which is very nearly
             * fsEstablished, we chose to extend the Idle time by a smidge.
             *
             * Changes state to bgp_fisExtended, to avoid doing this
             * more than once.
             */
            connection->idling_state = bgp_fisExtended ;
            continuation = Extension_Hold_Time ;
          }
        else
          {
            connection->idling_state = bgp_fisNULL ;    /* not fsIdle   */
            continuation = 0 ;                          /* done         */
          } ;
        break ;

      /* The timer is for IO_Hold_Time
       *
       * The continuation is the idle_pending, as set earlier.
       */
      case bgp_fisIO:
        qassert(connection->idle_time_pending != 0) ;

        connection->idling_state = bgp_fisHold ;
        continuation = connection->idle_time_pending | 1 ;

        break ;
    } ;

  connection->idle_time_pending = 0 ;           /* tidy         */

  /* Either set the continuation timer or proceed out of fsIdle.
   */
  if (continuation != 0)
    {
      qassert( (connection->idling_state == bgp_fisHold) ||
               (connection->idling_state == bgp_fisExtended) ) ;

      bgp_fsm_idle_hold_timer_set_interval(connection, continuation) ;
    }
  else
    {
      qassert(connection->idling_state == bgp_fisNULL) ;

      switch (connection->ord)
        {
          /* Enter fsConnect
           */
          case bc_connect:
            bgp_fsm_new_state(connection, bgp_fsConnect) ;
            bgp_fsm_do_connect(connection) ;
            break ;

          case bc_accept:
            bgp_fsm_new_state(connection, bgp_fsActive) ;

            connection->socket_event =
                             bgp_acceptor_state(connection->session->acceptor) ;
            if (connection->socket_event != bgp_feNULL)
              bgp_fsm_raise_meta_event(connection, bgp_fmSocket) ;
            break ;

          /* No idea what is going on here... so bring things to a sudden
           * stop.
           */
          default:
            qassert(false) ;
            bgp_fsm_exit(connection) ;
            break ;
        } ;
    } ;
} ;

/*------------------------------------------------------------------------------
 * Do connect() -- in fsConnect
 *
 * If connect succeeds, start the ConnectRetryTimer, otherwise stop it.
 *
 * If fails, an FSM event will have been raised, which will deal with in a
 * moment, and which will restart the ConnectRetryTimer.
 */
static void
bgp_fsm_do_connect(bgp_connection connection)
{
  qassert(connection->fsm_state == bgp_fsConnect) ;
  qassert(connection->ord   == bc_connect) ;

  bgp_connect(connection) ;
  bgp_connect_retry_timer_start(connection) ;
} ;

/*------------------------------------------------------------------------------
 * A connect() connection has come up.
 *
 * Send OPEN and proceed to fsOpenSent.
 *
 * TODO -- to implement OpenHoldTimer we put in a stutter step and stay in
 *         fsConnect -- to go by the RFC.
 */
static void
bgp_fsm_connected(bgp_connection connection)
{
  qassert(connection->fsm_state == bgp_fsConnect) ;

  /* Have qfile ready to go, need reader and writer and want to wind up the
   * connection level read/write action functions.  Also enable read-ready
   * and write-ready to get things moving.
   *
   * For good measure -- set an fmIO event, to make sure things are moving.
   */
  bgp_connection_io_start(connection) ;

  bgp_fsm_io_event(connection) ;

  /* OK... all set now to go fsOpenSent.
   */
  bgp_fsm_enter_open_sent(connection) ;
} ;

/*------------------------------------------------------------------------------
 * An accept() connection has come up -- apparently.
 *
 * Send OPEN and proceed to fsOpenSent or via fsOpenSent to fsConfirm.
 *
 * TODO -- to implement OpenHoldTimer we put in a stutter step and stay in
 *         fsConnect -- to go by the RFC.
 */
static void
bgp_fsm_accepted(bgp_connection connection)
{
  bool ok ;

  qassert(connection->fsm_state == bgp_fsActive) ;

  /* If the acceptor is still in a suitable state, we will be able to
   * co-opt its reader and qfile, and set up a writer and wind up the
   * connection level read/write action functions.  Also enable read-ready
   * and write-ready to get things moving.
   *
   * However... if the acceptor state has changed for the worse since the event
   * was raised, will not be able to do these things, and will stay in
   * fsActive.
   *
   * For good measure -- set an fmIO event, to make sure things are moving.
   */
  ok =  bgp_connection_io_start(connection) ;

  if (!ok)
    return ;

  bgp_fsm_io_event(connection) ;

  /* OK... all set now to go fsOpenSent.
   */
  bgp_fsm_enter_open_sent(connection) ;
} ;

/*------------------------------------------------------------------------------
 * Enter fsOpenSent state -- from fsConnect or fsActive.
 */
static void
bgp_fsm_enter_open_sent(bgp_connection connection)
{
  qassert( (connection->fsm_state == bgp_fsConnect) ||
           (connection->fsm_state == bgp_fsActive) ) ;

  if (connection->fsm_state == bgp_fsConnect)
    qassert(connection->ord == bc_connect) ;
  else
    qassert(connection->ord == bc_accept) ;

  bgp_fsm_new_state(connection, bgp_fsOpenSent) ;

  bgp_msg_write_open(connection) ;
  bgp_fsm_open_hold_timer_set(connection) ;
} ;

/*------------------------------------------------------------------------------
 * Enter fsOpenConfirm state -- from fsOpenSent.
 */
static void
bgp_fsm_enter_open_confirm(bgp_connection connection)
{
  bgp_connection sibling ;

  qassert(connection->fsm_state == bgp_fsOpenSent) ;

  /* If there is a sibling, and it is in fsOpenConfirm, then now must do
   * collision resolution -- either we will give up, or we will kill off
   * the sibling and proceed to fsOpenConfirm.
   */
  sibling = bgp_connection_get_sibling(connection) ;

  if ((sibling != NULL) && (sibling->fsm_state == bgp_fsOpenConfirm))
    {
      bgp_connection loser ;
      bgp_session    session ;
      bgp_id_t       remote_id, sibling_id, local_id ;

      session = connection->session ;

      /* Before choosing a winner, check that both have the same BGP Id.
       *
       * The two connections are to an address which is configured for the
       * given peer, and both have given the right ASN.  It would be
       * astonishing (but also disturbing) to find that they had different
       * BGP Ids !!!
       */
      remote_id  = connection->open_recv->sargs->remote_id ;
      sibling_id =    sibling->open_recv->sargs->remote_id ;

      if (remote_id != sibling_id)
        {
          plog_warn(connection->lox.log,
                                     "%s [FSM] received two BGP-ID: %s and %s",
                    connection->lox.name, siptoa(AF_INET, &remote_id).str,
                                          siptoa(AF_INET, &sibling_id).str) ;

          bgp_fsm_admin_event(connection, bgp_feBGPOpenMsgErr,
                                              bgp_msg_open_bad_id(remote_id)) ;
          bgp_fsm_admin_event(sibling,    bgp_feBGPOpenMsgErr,
                                              bgp_msg_open_bad_id(sibling_id)) ;
          return ;
        } ;

      /* NB: bgp_id in open_state is in *network* order
       */
      local_id = session->open_sent->sargs->local_id ;
      loser = (ntohl(local_id) < ntohl(remote_id)) ? connection
                                                   : sibling ;
      if (BGP_DEBUG(fsm, FSM))
        plog_debug(connection->lox.log,
                   "%s [FSM] BGP is loser in collision, fd %d",
                                     loser->lox.name, qfile_fd_get(loser->qf)) ;

      /* Throw feOpenCollisionDump at the loser, which will be in:
       *
       *    fsOpenConfirm -- if the loser is the sibling.
       *    fsOpenSent    -- if the loser is self
       *
       * Either way the loser drops to fsIdle.
       *
       * If the loser is us, we are done.
       */
      bgp_fsm_admin_event(loser, bgp_feOpenCollisionDump,
                         bgp_note_new(BGP_NOMC_CEASE, BGP_NOMS_C_COLLISION)) ;

      if (loser == connection)
        return ;
    } ;

  /* All is well: send a KEEPALIVE message to acknowledge the OPEN
   *
   *              change up to fsOpenConfirm
   */
  bgp_fsm_new_state(connection, bgp_fsOpenConfirm) ;

  bgp_msg_write_keepalive(connection, true /* must send */) ;

  bgp_fsm_hold_timer_set(connection) ;
  bgp_fsm_keepalive_timer_set(connection) ;
} ;

/*------------------------------------------------------------------------------
 * Go from fsOpenConfirm to fsEstablished.
 *
 * If there is another connection, that is now snuffed out and this connection
 * becomes the primary.  Also, if this is the out-bound connection, stamps on
 * the acceptor to squelch that, briefly.
 *
 */
static void
bgp_fsm_enter_established(bgp_connection connection)
{
  bgp_note       note ;
  bgp_connection sibling ;

  qassert(connection->fsm_state == bgp_fsOpenConfirm) ;

  /* Establish the session using this connection, if we can.
   */
  note = bgp_connection_establish(connection) ;

  if (note != NULL)
    {
      /* We were not able to accept the negotiated Capabilities.
       *
       * Ever hopeful, this will drop to idle and then come out again to see
       * if we get a better result !
       */
      bgp_fsm_admin_event(connection, bgp_feBGPOpenMsgErr, note) ;

      connection->cap_suppress = false ;
      return ;
    } ;

  /* Hurrah !  We have reached our goal... connection and session Established
   *
   * Now snuff out any sibling, and squelch any acceptor, if that is relevant.
   */
  bgp_fsm_new_state(connection, bgp_fsEstablished) ;

  sibling = bgp_connection_get_sibling(connection) ;

  if (sibling != NULL)
    {
      qassert(sibling->session == connection->session) ;

      bgp_fsm_admin_event(sibling, bgp_feAutomaticStop,
                          bgp_note_new(BGP_NOMC_CEASE, BGP_NOMS_C_COLLISION)) ;

      connection->session->connections[sibling->ord] = NULL ;
      sibling->session = NULL ;
    } ;

  if (connection->ord == bc_connect)
    bgp_acceptor_squelch(connection->session->acceptor) ;
} ;

/*------------------------------------------------------------------------------
 * About to leave established state.
 *
 * Will, momentarily, go fsStop, which will update the session state etc.
 *
 * Here we worry about the state of the ring-buffers, which are only valid
 * for the connection while is fsEstablished:
 *
 *   * for read_rb, if we are part way through reading a message into the
 *     ring buffer, adjust so will complete into the reader's temp_buff,
 *     so we can just forget the read_rb.
 *
 *   * for write_rb, if we are part way through writing a message from the
 *     ring-buffer, adjust so we complete the process form the writer's
 *     temp_buff, so we can just forget the write_rb.
 *
 *     For the writer if we need to move stuff around, may as well prepare
 *     enough buffer for any NOTIFICATION.
 */
static void
bgp_fsm_leave_established(bgp_connection connection, bgp_fsm_eqb eqb)
{
  qassert(connection->fsm_state == bgp_fsEstablished) ;

  bgp_msg_read_take_to_temp(connection->reader) ;
  connection->read_rb  = NULL ;

  bgp_msg_write_move_to_temp(connection->writer,
                                               bgp_note_msg_length(eqb->note)) ;
  connection->write_rb = NULL ;
} ;

/*==============================================================================
 * The BGP connections timers handling.
 *
 * The FSM has five timers (though, apart from the KeepaliveTimer, they all
 * use the connection->hold fsm_timer):
 *
 *   * IdleHoldTimer -- uses session->sargs.holdtime_secs with jitter
 *                   -- uses connection->hold fsm_timer
 *
 *     This runs while in Idle state, and is a period in which no connections
 *     are started, and none will be accepted.
 *
 *     The purpose of this timer is to slow down re-making connections with
 *     peers who are flapping or otherwise proving a nuisance.
 *
 *     This is a one shot timer, which generates a bgp_fsm_eStart event.
 *
 *   * ConnectRetryTimer -- uses session->sargs.connect_retry_secs with jitter
 *                       -- uses connection->hold fsm_timer
 *
 *     This runs while in sConnect or sActive state, and is the period for which
 *     the connection is prepared to wait between attempts to connect.
 *
 *     When trying to make a connect connection:
 *
 *       The primary connection (if any) will be in sConnect state.
 *
 *       The secondary connection (if any) will be in sActive state.
 *
 *       If nothing happens before the ConnectRetryTimer expires, then
 *       the connection attempt will be abandoned, and another started.
 *
 *       If the connection attempt fails, closes any connect() socket, but then
 *       waits for the ConnectRetryTimer to expire.
 *
 *     The ConnectRetryTimer recharges itself (with new jitter each time).  It
 *     generates a bgp_fsm_eConnectRetry event.
 *
 *  * OpenHoldTimer  -- uses connection->cops->open_hold_secs *without* jitter
 *                   -- uses connection->hold fsm_timer
 *
 *    This timer is used in sOpenSent state, and limits the time will wait for
 *    an Open to appear from the other end.  RFC4271 calls for this to be a
 *    "large value" -- suggesting 240 seconds.
 *
 *    This is a one shot timer, which generates a bgp_fsm_eHoldTimer
 *    event.
 *
 *  * HoldTimer  -- uses session->sargs.holdtime_secs *without* jitter
 *               -- uses connection->hold fsm_timer
 *
 *    This timer is used in sOpenConfirm and sEstablished states only.
 *
 *    This timer is also used in sOpenConfirm and sEstablished states, and
 *    limits the time the connection will be held if hear nothing from the
 *    other end.  In these states the timer is set to the negotiated HoldTime.
 *    If this is zero, then the HoldTime is infinite.
 *
 *    This timer is recharged every time some input arrives, and generates a
 *    bgp_fsm_eHoldTimer event (and stops) if it ever goes off.
 *
 *  * KeepaliveTimer -- uses session->sargs.keepalive_secs with jitter.
 *                   -- uses connection->keepalive fsm_timer
 *
 *    This timer is used in sOpenConfirm and sEstablished states only.
 *
 *    The default KeepalineTimer is 1/3 the HoldTimer, and is set from the
 *    negotiated HoldTime.  If that is zero, then the KeepaliveTime is also
 *    zero and treated as infinite, and no KEEPALIVE messages will be sent
 *    (other than the "ack" of the OPEN message).
 *
 *    This timer is recharged each time it goes off, and generates a
 *    bgp_fsm_eKeepaliveTimer event.
 */
static void bgp_fsm_timer_start(bgp_fsm_timer ft, qtime_t interval, uint jitter,
                              qtime_t interval_min, bgp_fsm_event_t fsm_event) ;
static void bgp_fsm_timer_suspend(bgp_fsm_timer ft) ;
static void bgp_fsm_timer_recharge(bgp_fsm_timer ft) ;

/*------------------------------------------------------------------------------
 * Set new IdleHoldTimer going -- with the current idle_hold_time
 *
 * The growth in IdleHoldTime can be suppressed by setting
 * cops->idle_hold_max_secs to zero...
 *
 * ...however,  we depend on there being a non-zero idle timer to kick the FSM
 * out of sIdle.  Also, we'd like some randomizing of starts, between
 * connections for the same session and when many connections are being started
 * at the same time.  Hence, we set a minimum IdleHoldTime of 1, which is then
 * jittered.
 */
static void
bgp_fsm_idle_hold_timer_set(bgp_connection connection)
{
  qtime_t interval ;

  interval = connection->idle_hold_time ;

  if (interval < QTIME(1))
    interval = QTIME(1) ;

  bgp_fsm_idle_hold_timer_set_interval(connection, interval) ;
} ;

/*------------------------------------------------------------------------------
 * Set new OpenHoldTimer going -- with the current open_hold_secs.
 *
 * This is the "long" timer in fsOpenSent.
 */
static void
bgp_fsm_open_hold_timer_set(bgp_connection connection)
{
  bgp_fsm_timer_start(connection->hold_timer,
                            QTIME(connection->cops->open_hold_secs), 0,
                                            QTIME(1), bgp_feHoldTimer_Expires) ;
} ;

/*------------------------------------------------------------------------------
 * Set new IdleHoldTimer going -- with the given interval.
 *
 * The IdleHoldTime can be suppressed by setting it to zero... which prevents
 * it from growing if connections keep falling back to fsIdle.
 *
 * However,  we depend on there being a non-zero idle timer to kick the FSM
 * out of sIdle.  Also, we'd like some randomizing of starts, between
 * connections for the same session and when many connections are being started
 * at the same time.  Hence, we set a minimum IdleHoldTime of 1, which is then
 * jittered.
 */
static void
bgp_fsm_idle_hold_timer_set_interval(bgp_connection connection,
                                                               qtime_t interval)
{
  bgp_fsm_timer_start(connection->hold_timer, interval, 20 /* % jitter */,
                              0 /* no minimum */, bgp_feIdleHoldTimer_Expires) ;
} ;

/*------------------------------------------------------------------------------
 * Calculate and set the next idle_hold_time.
 *
 * Note: if the cops->idle_hold_max_secs may be zero or small, which has the
 *       effect of suppressing DampPeerOscillations.
 *
 * Note: each time we try to increase the damping, we check against the now
 *       current cops->idle_hold_max_secs.
 *
 * Returns:  the (updated) IdleHoldTime -- 1..cops->idle_hold_max_secs
 */
static qtime_t
bgp_fsm_idle_hold_time_update(bgp_connection connection, bool damp)
{
  qtime_t interval, max_interval ;

  interval = connection->idle_hold_time ;
  if (damp)
    interval *= 2 ;

  max_interval = QTIME(connection->cops->idle_hold_max_secs) ;
  if (interval > max_interval)
    interval = max_interval ;   /* clamp to required maximum            */

  if (interval < QTIME(1))
    interval = QTIME(1) ;       /* but *never* less than 1 second       */

  return connection->idle_hold_time = interval ;
} ;

/*------------------------------------------------------------------------------
 * Start (or restart) the ConnectRetryTimer
 *
 * No matter what the configuration says, will set a timer of at least 1
 * second !
 */
static void
bgp_connect_retry_timer_start(bgp_connection connection)
{
  bgp_fsm_timer_start(connection->hold_timer,
                         QTIME(connection->cops->connect_retry_secs),
                                25, QTIME(1), bgp_feConnectRetryTimer_Expires) ;
} ;

/*------------------------------------------------------------------------------
 * Set HoldTimer going (unless suppressed) -- for fsEstablished.
 *
 * If the negotiated HoldTime value is zero then no HoldTimer is set (and
 * no KeepaliveTimer will be set, either.
 *
 * Otherwise, RFC4271 specifies that the the minimum, non-zero HoldTime is 3.
 */
static void
bgp_fsm_hold_timer_set(bgp_connection connection)
{
  uint holdtime_secs ;

  holdtime_secs  = connection->session->sargs->holdtime_secs ;

  connection->holdtimer_suppressed = (holdtime_secs == 0) ;

  if (connection->holdtimer_suppressed)
    bgp_fsm_timer_stop(connection->hold_timer) ;
  else
    bgp_fsm_timer_start(connection->hold_timer, QTIME(holdtime_secs), 0,
                                            QTIME(3), bgp_feHoldTimer_Expires) ;
} ;

/*------------------------------------------------------------------------------
 * Set KeepaliveTimer going (unless suppressed).
 *
 * If the negotiated HoldTime value is zero, then the KeepaliveTime value
 * is also nominally zero.  However, we run the keepalive_timer in any case,
 * we just don't send any KEEPALIVE messages.  See note below.
 *
 * Otherwise, RFC4271 specifies that the (default) KeepaliveTime is 1/3 of the
 * HoldTime (and the minimum, non-zero HoldTime is 3).  We here calculate the
 * KeepaliveTime in nano-seconds:
 *
 *   * if the keepalive_secs is < holdtime_secs / 3, we have an explicit
 *     KeepaliveTime, and we use exactly that, in nano-seconds.
 *
 *   * otherwise we use HoldTime in nanoseconds / 3
 *
 * RFC4271 specifies that, unless it is turned off altogether, the minimum
 * KeepAliveTime is 1 second.  That interacts with the jitter which SHOULD (by
 * the RFC) be applied to the KeepAliveTimer.  This only affects a HoldTime of
 * 3 (which is a bit mad) -- but even with this kludge, we will send 2
 * KEEPALIVEs within a HoldTime of 3 (the maximum jittered interval is approx
 * 1.25 seconds).
 *
 * Note that one effect of the keepalive_timer is that every time it goes off
 * we will, provided the output buffer is empty, force write-ready -- whether
 * we actually send a KEEPALIVE message or not.  This is so that the raw
 * writer will run, and that will, at the very least, check for I/O errors.
 * This means that even if the read-buffers have backed up and the reader is
 * no longer read-ready, we still check periodically for connection issues.
 */
static void
bgp_fsm_keepalive_timer_set(bgp_connection connection)
{
  uint holdtime_secs ;
  qtime_t interval ;

  holdtime_secs  = connection->session->sargs->holdtime_secs ;

  connection->holdtimer_suppressed = (holdtime_secs == 0) ;

  if (connection->holdtimer_suppressed)
    interval = QTIME(90 / 3) ;  /* standard 1/3 of suggested HoldTime   */
  else
    {
      uint    keepalive_secs ;

      keepalive_secs = connection->session->sargs->keepalive_secs ;
      if (holdtime_secs < 3)
        holdtime_secs = 3 ;             /* pure paranoia        */

      if ((keepalive_secs < (holdtime_secs / 3)) && (keepalive_secs != 0))
        interval = QTIME(keepalive_secs) ;
      else
        interval = QTIME(holdtime_secs) / 3 ;
    } ;

  bgp_fsm_timer_start(connection->keepalive_timer, interval, 25,
                                       QTIME(1), bgp_feKeepaliveTimer_Expires) ;
} ;

/*------------------------------------------------------------------------------
 * Restart KeepaliveTimer (unless suppressed).
 *
 * If was active, this resets the timer interval ) complete with jitter.
 *         otherwise, this sets the timer going  )
 */
extern void
bgp_keepalive_timer_recharge(bgp_connection connection)
{
  bgp_fsm_timer_recharge(connection->keepalive_timer) ;
} ;

/*------------------------------------------------------------------------------
 * Suspend the KeepaliveTimer, if it is running.
 *
 * Suspend is different from Stop -- suspend unsets the qtimer, but leaves the
 * rest of the
 *
 * This is done when the connection goes "write-ready" -- so there is something
 * waiting to be sent.  The KeepaliveTimer is recharged when there is nothing
 * more to send.
 */
extern void
bgp_keepalive_timer_suspend(bgp_connection connection)
{
  bgp_fsm_timer_suspend(connection->keepalive_timer) ;
} ;

/*==============================================================================
 * The bgp_fsm_timer mechanics
 */
static qrand_seq_t jseq = QRAND_SEQ_INIT(314159265) ;

static void bgp_fsm_timer_action(qtimer qtr, void* timer_info,
                                                            qtime_mono_t when) ;
inline static void bgp_fsm_timer_event_clear(bgp_fsm_timer ft) ;

/*------------------------------------------------------------------------------
 * Initialise fsm timer
 *
 * Set up qtimer object for the timer
 *
 * NB: these are embedded in the connection object
 */
extern void
bgp_fsm_timer_init(bgp_fsm_timer ft, bgp_connection connection)
{
  memset(ft, 0, sizeof(bgp_fsm_timer_t)) ;

  /* Zeroizing clears out:
   *
   *   * connection             -- X        -- set below
   *   * fsm_meta               -- bgp_fmNULL
   *   * fsm_event              -- bgp_feNULL
   *
   *   * timer                  -- X        -- set below
   *   * interval               -- 0        -- timer unset
   *   * jitter                 -- 0        )
   *   * jitter_unit            -- 0        )  none
   *
   *   * state                  -- bfts_stopped
   */
  confirm(bgp_fmNULL   == 0) ;
  confirm(bgp_feNULL   == 0) ;
  confirm(bfts_stopped == 0) ;

  ft->connection = connection ;
  ft->qtr = qtimer_init_new(NULL, be_nexus->pile, NULL, ft) ;
} ;

/*------------------------------------------------------------------------------
 * Start given fsm_timer with the given state, ready to raise the given event.
 *
 * Clears any outstanding timer event.
 *
 * If the given interval is 0 sets either the given minimum, or a very small,
 * but non-zero, interval.
 *
 * The jitter is in maximum % to be subtracted.  So 25 gives actual interval
 * ~75%..~100% of its given value.  (0 jitter => no jitter).
 *
 * What actually does is to set the timer's interval to the minimum after
 * application of any jitter, or to the given interval_min.  If there is
 * jitter, the jitter_unit is set according to the original interval, and
 * some multiple of that is added to apply the jitter.
 *
 * Suppose the interval_min is 2 seconds.  If an interval of 1 second is set,
 * with a 20% jitter, the result will be an interval of 2.00..2.20 seconds
 * (the minimum up to 20% of the request).  If an interval of 0.5 seconds is
 * set with 20% jitter -> 2.00..2.10.  So, if the minimum is enforced, the
 * jitter is still proportional to the requested interval.
 */
static void
bgp_fsm_timer_start(bgp_fsm_timer ft, qtime_t interval, uint jitter,
                                qtime_t interval_min, bgp_fsm_event_t fsm_event)
{
  bgp_fsm_meta_t fsm_meta ;

  bgp_fsm_timer_event_clear(ft) ;

  switch (fsm_event)
    {
      case bgp_feKeepaliveTimer_Expires:
        fsm_meta   = bgp_fmKeepaliveTimer ;
        break ;

      default:
        qassert(false) ;
        fall_through ;

      case bgp_feConnectRetryTimer_Expires:
      case bgp_feHoldTimer_Expires:
      case bgp_feDelayOpenTimer_Expires:
      case bgp_feIdleHoldTimer_Expires:
        fsm_meta   = bgp_fmHoldTimer ;
        break ;
    } ;

  ft->fsm_meta   = fsm_meta ;
  ft->fsm_event  = fsm_event ;

  if (interval < QTIME_MICRO_SECONDS(10))
    {
      /* Interval so small that jitter is moot !
       */
      ft->interval    = QTIME_MICRO_SECONDS(10) ;
      ft->jitter      = 0 ;
      ft->jitter_unit = 0 ;
    }
  else if (jitter == 0)
    {
      /* No jitter, or interval so small that jitter is moot !
       */
      ft->interval    = interval ;
      ft->jitter      = 0 ;
      ft->jitter_unit = 0 ;
    }
  else
    {
      /* Calculate ft->interval, ft->jitter and ft->jitter_unit.
       *
       * What we do (approximately) is set:
       *
       *   ft->interval    = (interval * (100 - jitter) / 100
       *   ft->jitter      = jitter
       *   ft->jitter_unit = (interval / 100)
       *
       * So that the jittered interval is:
       *
       *   ft->interval + (qrand(ft->jitter) * ft->jitter_unit)
       *
       * Now, we are doing all this in integer arithmetic, so we have to
       * scale things to get the fractions to work.  So, scaling by 'js'
       * we have:
       *
       *   ft->interval    = ((interval * (100 - jitter)) + 99) / 100
       *   ft->jitter      = jitter * js
       *   ft->jitter_unit = interval / (100 * js)
       *
       * Note that we round the ft->interval up, which ensures it is never
       * zero.  But this does mean that the nominal minimum jittered
       * interval may never be (quite) achieved.
       *
       * If we choose a scale of 10,000, then the jitter_unit is,
       * effectively, in milliseconds.  What we actually set is:
       *
       *   ft->jitter_unit = (interval / (100 * js)) | 1
       *
       * Which has two effects: (a) it ensures that when the random jitter
       * is multiplied by the unit, the ls bits of the result are affected
       * by the jitter, and (b) if the interval is stupidly small, there
       * is some jitter !  What (a) does is round up, except where the
       * interval is an exact multiple of milliseconds (which it usually
       * is) in which case it adds 1.
       *
       * Suppose an interval of 1 second, and a jitter of 25%:
       *
       *   ft->interval    = ((1,000,000,000 * (100 - 25) + 99) / 100
       *                   = 750,000,000 nano-seconds
       *
       *   ft->jitter      = 25 * js = 250,000
       *
       *   ft->jitter_unit = (1,000,000,000 / (100 * js)) | 1
       *                   = 1,001 ;
       *
       * If qrand(ft->jitter) comes up zero, we get ft->interval.
       *
       * If qrand(ft->jitter) comes up maximum we get:
       *
       *   ft->interval + (249,999 * 1,001) = 1.000_248_999 seconds
       *
       * Which is a touch over the nominal maximum.  For a 90 second
       * interval the maximum is 90.000_159_999 seconds.
       *
       * Now, if the ft->interval is less than the given interval_min, it is
       * set to that interval_min.
       *
       * NB: if ft->interval < interval_min, then the jittered interval may
       *     be much greater than the nominal interval.
       *
       *     If interval = interval_min = 1.000_000_000 second and the
       *     jitter is 25%, then the maximum jittered interval is:
       *
       *       1.250_248_999 seconds.
       *
       *     If interval = 1.333_333_334 and interval_min = 1.000_000_000
       *     and the jitter is 25%, then the minimum jittered interval is
       *     1.000_000_001 (so interval_min is moot).
       *
       * NB: the interval can be 1,001 *days* and not overflow the arithmetic.
       */
      enum{ js = 10000, thousand_and_one_days = 1001*24*60*60 } ;

      qassert(jitter   <= 99) ;
      qassert(interval <= QTIME(thousand_and_one_days)) ;

      if (jitter > 99)
        jitter = 99 ;

      if (interval > QTIME(thousand_and_one_days))
        interval = QTIME(thousand_and_one_days) ;

      confirm(QTIME(thousand_and_one_days) < ((QTIME_MAX / 99) - 99)) ;

      ft->interval    = ((interval * (100 - jitter)) + 99) / 100 ;
      ft->jitter      = jitter * js ;
      ft->jitter_unit = (interval / (100 * js)) | 1 ;

      qassert(ft->interval != 0) ;
    } ;

  if (ft->interval < interval_min)
    ft->interval = interval_min ;

  bgp_fsm_timer_recharge(ft) ;
} ;

/*------------------------------------------------------------------------------
 * Suspend given fsm_timer -- no effect if is not bfts_running or bfts_expired.
 *
 * If is bfts_expired, any stale event is discarded.
 */
static void
bgp_fsm_timer_suspend(bgp_fsm_timer ft)
{
  switch (ft->state)
    {
      case bfts_stopped:
      case bfts_suspended:
      default:
        break ;

      case bfts_running:
        qtimer_unset(ft->qtr) ;
        ft->state = bfts_suspended ;
        break ;

      case bfts_expired:
        bgp_fsm_timer_event_clear(ft) ;
        ft->state = bfts_suspended ;
        break ;
    } ;
} ;

/*------------------------------------------------------------------------------
 * Unsuspend given fsm_timer -- no effect if is not bfts_suspended.
 *
 * If was suspended, re-charge.
 */
static void
bgp_fsm_timer_unsuspend(bgp_fsm_timer ft)
{
  if (ft->state == bfts_suspended)
    bgp_fsm_timer_recharge(ft) ;
} ;

/*------------------------------------------------------------------------------
 * Stop given fsm_timer -- discards all parameters, and unsets the timer.
 *
 * If the timer has already gone off, then the event generated is cleared.
 *
 * Clears out everything except the underlying qtr, which ensures is unset.
 */
extern void
bgp_fsm_timer_stop(bgp_fsm_timer ft)
{
  bgp_fsm_timer_event_clear(ft) ;

  ft->interval    = 0 ;
  ft->jitter      = 0 ;
  ft->jitter_unit = 0 ;

  ft->state       = bfts_stopped ;

  qtimer_unset(ft->qtr) ;     /* no effect if not active      */
} ;

/*------------------------------------------------------------------------------
 * Recharge (or start) given bgp_fsm_timer.
 *
 * If the timer has already gone off, then the event generated is cleared.
 *
 * Do nothing if the current interval is zero -- ie timer has been stopped.
 *
 * If was active, this resets the timer interval ) complete with jitter.
 *         otherwise, this sets the timer going  )
 */
static void
bgp_fsm_timer_recharge(bgp_fsm_timer ft)
{
  qtime_t interval ;

  if (ft->state == bfts_expired)
    bgp_fsm_timer_event_clear(ft) ;

  interval = ft->interval ;

  if (interval == 0)
    ft->state = bfts_stopped ;  /* make sure    */
  else
    {
      if (ft->jitter != 0)
        interval += qrand(jseq, ft->jitter) * ft->jitter_unit;

      qtimer_set_interval(ft->qtr, interval, bgp_fsm_timer_action) ;

      ft->state = bfts_running ;
    } ;
} ;

/*------------------------------------------------------------------------------
 * If the given timer has expired, the event is stale and must be cleared.
 *
 * When an fsm_timer goes of, it is set expired and an event is raised.
 *
 * When the event is processed, the timer event will be cleared.
 */
inline static void
bgp_fsm_timer_event_clear(bgp_fsm_timer ft)
{
  if (ft->state == bfts_expired)
    {
      ft->connection->meta_events &= ~ft->fsm_meta ;
      ft->state = bfts_stopped ;
    } ;
} ;

/*------------------------------------------------------------------------------
 * Stop given fsm_timer and free off the component qtimer.
 *
 * NB: bgp_fsm_timer are embedded in the connection object
 */
extern void
bgp_fsm_timer_free(bgp_fsm_timer ft)
{
  bgp_fsm_timer_stop(ft) ;
  ft->qtr = qtimer_free(ft->qtr) ;
} ;

/*------------------------------------------------------------------------------
 * fsm_timer, generic action
 */
static void
bgp_fsm_timer_action(qtimer qtr, void* timer_info, qtime_mono_t when)
{
  bgp_fsm_timer  ft ;
  bgp_connection connection ;

  ft = timer_info ;
  qassert(qtr == ft->qtr) ;

  connection = ft->connection ;

  if (BGP_DEBUG (fsm, FSM)) \
    plog_debug (connection->lox.log, "%s [FSM] Timer: %s", connection->lox.name,
                            map_direct(bgp_fsm_event_map, ft->fsm_event).str) ;

  ft->state = bfts_expired ;

  bgp_fsm_raise_meta_event(connection,ft->fsm_meta) ;
} ;

/*==============================================================================
 * The FSM <-> Reader/Writer and Ring-Buffers stuff
 */

/*------------------------------------------------------------------------------
 * Signal an feIO "event" -- unless one is already in flight.
 */
extern void
bgp_fsm_io_event(bgp_connection connection)
{
  if (!(connection->meta_events & bgp_fmIO))
    bgp_fsm_raise_meta_event(connection, bgp_fmIO) ;
}

/*------------------------------------------------------------------------------
 * Deal with all purpose I/O "event" arriving from the I/O "process".
 *
 * If there is a message or an error for the FSM to handle, an feXXXX event
 * is written into the given eqb, ready for immediate processing.  And, an
 * fmIO meta-event is set, so that once all other queued events, and any higher
 * priority meta-events have been processed, will again deal with anu I/O.
 *
 * Nearly all I/O is performed in fsEstablished, and this function will loop
 * internally hoovering up as many messages as are to hand, all in one go.
 *
 *   * feNULL  -- nothing (more) to be done
 *
 *   * feBGPHeaderErr,      with NOTIFICATION   -- SHUT_RD, connection-wise
 *
 *   * feBGPOpen, parsed to open_recv, message in reader->temp_buff
 *
 *   * feBGPOpenMsgErr,     with NOTIFICATION   -- SHUT_RD, connection-wise
 *
 *   * feNotifyMsgVerErr,   with NOTIFICATION   -- SHUT_RD, connection-wise
 *
 *   * feNotifyMsg,         with NOTIFICATION   -- SHUT_RD, connection-wise
 *
 *   * feKeepAliveMsg, iff not fsEstablished
 *
 *   * feUpdateMsg,    iff not fsEstablished
 *                     message in reader->temp_buff.
 *
 *   * feRRMsg,        iff fsEstablished: data -> Route Refresh object
 *                     in any case, message in reader->temp_buff.
 *
 *   * feRRMsgErr,          with NOTIFICATION   -- SHUT_RD, connection-wise
 *                     message in reader->temp_buff.
 *
 *   * feDown                        -- SHUT_RD or SHUT_WR, connection-wise
 *
 *   * feError                       -- SHUT_RD or SHUT_WR, connection-wise
 *
 *   * feShut_RD                                -- SHUT_RD, connection-wise
 *
 *   * feShut_WR                                -- SHUT_WR, connection-wise
 *
 *   * feInvalid,           with NOTIFICATION   -- connection down
 *
 * Returns:  fsm_event as required.
 *
 * NB: fills in eqb->notification and eqb->err if required.
 *
 *     Does NOT set eqb->fsm_event.
 *
 * NB: clears the fmIO meta-event if there is no more I/O to be done at
 *     present.
 */
static bgp_fsm_event_t
bgp_fsm_do_io(bgp_connection connection, bgp_fsm_eqb eqb)
{
  qfile_state_t   io_state ;
  bgp_fsm_event_t fsm_event ;
  bgp_msg_reader  reader ;
  bool established ;

  qassert(eqb->note == NULL) ;
  qassert(eqb->err  == 0) ;

  io_state  = connection->io_state ;
  fsm_event = bgp_feNULL ;      /* nothing, yet         */

  /* If we have an active writer, deal with that first.
   *
   * This will move as much stuff as possible into the writer buffer, and
   * kick the pselect "process" as required.  Once this is done, there is
   * no more write IO until is kicked again -- either by pselect or by
   * the Routeing Engine.
   *
   * If the writer finds that the socket is no longer open for writing (ie
   * gets an EPIPE), then we log that for debug purposes and then SHUT_WR
   * at our end.  We assume that the reader will encounter EOF, or may fail,
   * or receive a NOTIFICATION... but in any case this is not an "error"
   * as such.
   *
   * Note that if the writer has detected an I/O error, the connection will
   * be SHUT_WR, and a suitable event generated.
   *
   * So... where there is a race between reader and writer to pick up some
   * error, and the writer gets there first, this will signal the error, and
   * the reader will signal SHUT_RD in due course.
   *
   * Note also that *only* if there is an I/O error will the writer side
   * generate an event.
   */
  if (io_state & qfUp_WR)
    {
      int sock_fd, err ;

      bgp_msg_write_stuff(connection, connection->write_rb) ;

      switch(connection->writer->state)
        {
          /* All is well, or we are still waiting to empty out the buffer(s).
           */
          case bws_ok:
            if (rb_put_prompt(connection->write_rb, 10000))
              bgp_session_kick_re_write(connection->session) ;
            break ;

          /* OK, but waiting to empty out the buffer(s).
           */
          case bws_clearing:
            break ;

          /* Was bws_clearing, and the buffers are now empty.
           *
           * Or, writer has hit an error, but the reader has already been shut,
           * on eof or an error of its own -- at least at the qfile level.
           *
           * Either way, we can now shut the writer at the connection level.
           *
           * The reader may or may not be shut at the connection level, but
           * in any case we issue an feShut_WR event.  If the reader is still
           * up, then the feShut_WR will bounce the FSM into fsIdle, where it
           * will later be handed an feDown or feError.  It is most important
           * to bounce the FSM out of fsEstablished at the first hint of
           * trouble.
           */
          case bws_down:
            bgp_connection_shut_wr(connection) ;
            return bgp_feShut_WR ;      /* <<< exit     */

          /* Deal with error cases.
           *
           * The writer has bagged the error.  So, we signal a suitable error
           * event, and log it and everything.
           */
          case bws_shut:
          case bws_io_error:
            bgp_connection_shut_wr(connection) ;

            sock_fd  = qfile_fd_get(connection->qf) ;
            err      = qfile_err_get(connection->qf) ;

            eqb->err = err ;
            return bgp_fsm_io_failed(&connection->lox, sock_fd, err, "write" ) ;

          default:
            qassert(false) ;
            eqb->note = bgp_note_new(BGP_NOMC_CEASE, BGP_NOMS_UNSPECIFIC) ;
            bgp_connection_down(connection) ;

            return bgp_feInvalid ;
        } ;
    } ;

  /* Now, if we do not have an active reader, we are done.
   */
  if (!(io_state & qfUp_RD))
    {
      connection->meta_events &= ~bgp_fmIO ;
      return fsm_event ;
    } ;

  /* Deal with reader.
   *
   * In fsEstablished we eat KEEPALIVE and UPDATE messages here and now, so
   * the main FSM is not bothered with the vast majority of messages !  Note
   * that this means that we deal with suspending and un-suspending of the
   * HoldTimer in here.
   *
   * Errors and EOF are detected down in the bgp_msg_read_raw(), and are
   * trapped in the reader->state.  Those will, eventually, emerge when all
   * (complete) messages which preceded same have been processed.  The qfile
   * state and error will reflect the bgp_msg_read_raw() state.  When the
   * error/EOF emerges, here we finally do any logging and update the
   * connection->io_state.
   */
  reader = connection->reader ;

  established = (connection->fsm_state == bgp_fsEstablished) ;

  /* The while(1) allows us to use "continue" to loop round to consider a
   * new msg_state.  This is used when established and is processing
   * UPDATE, RR, and KEEPALIVE messages.
   */
  while (1)
    {
      bool version_error ;

      qassert(fsm_event == bgp_feNULL) ;

      switch (reader->msg_state)
        {
          /* Nothing more to be done if we are waiting for a header or for
           * a partial message to be completed -- except that while we are
           * fsEstablished, and the HoldTimer has been suspended, then now
           * is the time to un-suspend it.
           */
          case bms_await_header:
            if (established)
              bgp_fsm_timer_unsuspend(connection->hold_timer) ;
            break ;

          /* If we are bms_partial, then we the header and part, but not all
           * of another message -- so there is nothing more to be read.
           *
           * For fsEstablished we need the HoldTimer to be running again, if
           * we have stopped it.
           *
           * If the partial message is 'in-hand' we take what we have, so far,
           * to its destination, and then leave the reader to complete things
           * into that buffer.  This is for two reasons:
           *
           *   a) may as well avoid copying stuff we don't need to copy !
           *
           *   b) the reader buffer is not *required* to be as big as the
           *      biggest possible message -- which may become more relevant
           *      as messages are allowed to be up to 64k !
           *
           * If the partial message is not 'in-hand', then we are still
           * waiting... which implies we have been called but actually have
           * nothing to do.
           */
          case bms_partial:
            if (established)
              bgp_fsm_timer_unsuspend(connection->hold_timer) ;

            if (reader->msg_in_state == bms_in_hand)
              {
                if (established && (reader->msg_qtype == qBGP_MSG_UPDATE))
                  {
                    /* Special case.  UPDATE and fsEstablished.
                     *
                     * We will want the message in the ring-buffer, so start
                     * as we mean to go on.
                     */
                    ptr_t msg_buff ;

                    msg_buff = rb_put_open(connection->read_rb,
                                               reader->msg_body_length,
                                                       true /* set waiting */) ;
                    if (msg_buff != NULL)
                      bgp_msg_read_take(msg_buff, reader) ;
                  }
                else
                  {
                    /* Everything else goes into the temp, even if we
                     * eventually transfer to the ring-buffer... keeping
                     * things as simple as possible.
                     */
                    bgp_msg_read_take_to_temp(reader) ;
                  } ;
              } ;
            break  ;

          /* For a complete message -- known or unknown
           *
           * Whatever the message, can now suspend HoldTimer until we are
           * again waiting for a message.
           *
           * Except for UPDATE messages in fsEstablished, the message body
           * is sitting in the reader's temp buffer @ reader->msg_body.  Whence
           * it can be parsed etc., before we are done with it.
           */
          case bms_complete:
            if (established)
              {
                /* We need to deal with the HoldTimer.
                 *
                 * We expect UPDATEs, but need to deal with the ring-buffer.
                 *
                 * If the ring-buffer is full, we need to get out of here.
                 */
                bgp_fsm_timer_suspend(connection->hold_timer) ;

                if (reader->msg_qtype == qBGP_MSG_UPDATE)
                  {
                    if (reader->msg_in_state == bms_in_hand)
                      {
                        /* This means that either the message has arrived
                         * bms_complete all in one go (a likely event) or
                         * the ring buffer was full when we saw an earlier
                         * bms_partial.
                         *
                         * Either way, we want to take the message into the
                         * ring-buffer.
                         */
                        ptr_t msg_buff ;

                        msg_buff = rb_put_open(connection->read_rb,
                                                   reader->msg_body_length,
                                                       true /* set waiting */) ;
                        if (msg_buff != NULL)
                          bgp_msg_read_take(msg_buff, reader) ;
                        else
                          break ;               /* ring buffer full :-( */
                      } ;

                    qassert(reader->msg_in_state == bms_in_other) ;
                  } ;
              } ;

            switch (reader->msg_in_state)
              {
                default:
                  qassert(false) ;
                  break ;

                /* If the message is in-hand, that means a message has
                 * completed in the read buffer -- a likely event.
                 *
                 * We have pealed off established and qBGP_MSG_UPDATE already.
                 */
                case bms_in_hand:
                  qassert(!established ||
                                       (reader->msg_qtype != qBGP_MSG_UPDATE)) ;
                  bgp_msg_read_take_to_temp(reader) ;
                  break ;

                /* If already in the temp_buff, that's fine.
                 */
                case bms_in_temp:
                  break ;

                /* If the message is in-hand, that means a message has
                 * has been taken to the ring-buffer.
                 *
                 * Must be established and qBGP_MSG_UPDATE.
                 */
                case bms_in_other:
                  qassert(established &&
                                       (reader->msg_qtype == qBGP_MSG_UPDATE)) ;

                  rb_put_close(connection->read_rb,
                                   reader->msg_body_length, bgp_rbm_in_update) ;
                  break ;
              } ;

            /* Now do any logging that is required of us.
             */
            if (bgp_dump_packet_flag && (connection->session != NULL))
              bgp_dump_packet(connection->session, reader->msg_body,
                                reader->msg_body_length, reader->msg_bgp_type) ;

            if (BGP_DEBUG (io, IO_IN))
              bgp_msg_read_log(reader) ;

            switch(reader->msg_qtype)
              {
                /* What we don't recognise, we reject as a bad message type.
                 *
                 * Should logging or other stuff require it, the raw message
                 * is in the reader->temp_buff etc.
                 */
                case qBGP_MSG_unknown:
                case qBGP_MSG_CAPABILITY:
                default:
                  eqb->note = bgp_msg_read_bad_type(reader) ;

                  bgp_connection_shut_rd(connection) ;
                  fsm_event = bgp_feBGPHeaderErr ;
                  break ;

                /* We parse the OPEN message straight out of the temp buffer.
                 *
                 * Should logging or other stuff require it, the raw message
                 * is in the reader->temp_buff etc.
                 */
                case qBGP_MSG_OPEN:
                  eqb->note = bgp_msg_open_parse(connection, reader) ;

                  if (eqb->note == NULL)
                    {
                      bgp_msg_read_done(reader) ;
                      fsm_event = bgp_feBGPOpen ;
                    }
                  else
                    {
                      bgp_connection_shut_rd(connection) ;
                      fsm_event = bgp_feBGPOpenMsgErr ;
                    } ;
                  break ;

                /* We parse the NOTIFICATION message straight out of the
                 * temp buffer.
                 *
                 * Should logging or other stuff require it, the raw message
                 * is in the reader->temp_buff etc.
                 */
                case qBGP_MSG_NOTIFICATION:
                  eqb->note = bgp_msg_notify_parse(connection, reader) ;

                  version_error = (eqb->note->code    == BGP_NOMC_OPEN) &&
                                  (eqb->note->subcode == BGP_NOMS_O_VERSION) ;

                  bgp_connection_shut_rd(connection) ;
                  fsm_event = version_error ? bgp_feNotifyMsgVerErr
                                            : bgp_feNotifyMsg ;
                  break ;

                /* KEEPALIVE is trivial !
                 *
                 * For fsEstablished we suspend the HoldTimer, since we just
                 * got something, then poke ahead to see if we have anything
                 * more to process.
                 *
                 * Otherwise, return an feKeepAliveMsg event.
                 */
                case qBGP_MSG_KEEPALIVE:
                  if (BGP_DEBUG (keepalive, KEEPALIVE) && !BGP_DEBUG(io, IO_IN))
                    plog_debug(reader->plox->log, "%s KEEPALIVE rcvd",
                                                           reader->plox->name) ;
                  bgp_msg_read_done(reader) ;

                  if (established)
                    continue ;                  /* all the way back     */ ;

                  fsm_event = bgp_feKeepAliveMsg ;
                  break ;

                /* For UPDATE messages in fsEstablished...
                 *
                 * Otherwise, return an bgp_feUpdateMsg event (probably fatal).
                 *
                 * Should logging or other stuff require it, the raw message
                 * is in the reader->temp_buff etc.
                 */
                case qBGP_MSG_UPDATE:
                  bgp_msg_read_done(reader) ;

                  if (established)
                    continue ;                  /* all the way back     */ ;

                  fsm_event = bgp_feUpdateMsg ;
                  break ;

                /* We read ROUTE_REFRESH message straight out of the
                 * temp buffer.
                 *
                 * Should logging or other stuff require it, the raw message
                 * is in the reader->temp_buff etc.
                 */
                case qBGP_MSG_ROUTE_REFRESH:
                case qBGP_MSG_ROUTE_REFRESH_pre:
                  eqb->note = bgp_msg_route_refresh_parse(connection, reader) ;
                  if (eqb->note == NULL)
                    {
                      /* The Route Refresh message is of an acceptable type
                       * and for negotiated AFI/SAFI.
                       *
                       * If established, we move the message to the ring buffer
                       */
                      if (established)
                        {
                          bgp_rb_msg_in_type_t rb_msg_type ;
                          ptr_t msg_buff ;

                          rb_msg_type =
                                (reader->msg_qtype == qBGP_MSG_ROUTE_REFRESH)
                                  ? bgp_rbm_in_rr : bgp_rbm_in_rr_pre ;

                          msg_buff = rb_put_open(connection->read_rb,
                                                 reader->msg_body_length,
                                                     true /* set waiting */) ;
                          if (msg_buff == NULL)
                            break ;             /* ring-buffer full :-( */

                          bgp_msg_read_take(msg_buff, reader) ;

                          rb_put_close(connection->read_rb,
                                         reader->msg_body_length, rb_msg_type) ;
                        } ;

                      bgp_msg_read_done(reader) ;
                      fsm_event = bgp_feRRMsg ;
                    }
                  else
                    {
                      bgp_connection_shut_rd(connection) ;
                      fsm_event = bgp_feRRMsgErr ;
                    } ;
                  break ;
              } ;

            break ;

          /* Now we are dealing with errors detected by the reader.
           *
           * This logs as required, and will then SHUT_RD the reader
           */
          case bms_complete_too_short:
          case bms_complete_too_long:
            switch (reader->msg_in_state)
              {
                default:
                  qassert(false) ;
                  break ;

                /* If the message is in-hand, that means a message has
                 * completed in the read buffer -- a likely event.
                 *
                 * In all cases we want the message in the temp_buff, for
                 * reference.
                 */
                case bms_in_hand:
                  bgp_msg_read_take_to_temp(reader) ;
                  break ;

                /* If already in the temp_buff, that's fine.
                 */
                case bms_in_temp:
                  break ;

                /* Was being put into the ring-buffer, but since this is a
                 * failure, better move everything to the temp_buff.
                 */
                case bms_in_other:
                  bgp_msg_read_take_to_temp(reader) ;

                  rb_put_drop(connection->read_rb) ;
                  break ;
              } ;

            bgp_msg_read_done(reader) ;

            bgp_connection_shut_rd(connection) ;

            eqb->note = bgp_msg_read_bad(reader, connection->qf) ;
            fsm_event = bgp_feBGPHeaderErr ;
            break ;

          case bms_fail_bad_length:
          case bms_fail_bad_marker:
            bgp_connection_shut_rd(connection) ;

            eqb->note = bgp_msg_read_bad(reader, connection->qf) ;
            fsm_event = bgp_feBGPHeaderErr ;
            break ;

           /* NB: if is in these states, then the reader "bagged" the error
            *     before the writer got to it.
            */
          case bms_fail_eof:
          case bms_fail_io:
            bgp_connection_shut_rd(connection) ;

            eqb->err  = qfile_err_get(connection->qf) ;
            fsm_event = bgp_msg_read_failed(reader, connection->qf) ;
            break ;

          /* In this state the writer "bagged" any error, and has issued the
           * appropriate event.
           *
           * We issue an feShut_RD event to signal that the reader is now
           * down, connection-wise.
           */
          case bms_fail_down:
            bgp_connection_shut_rd(connection) ;

            fsm_event = bgp_feShut_RD ;
            break ;

          /* We don't know what's going on here => throw an feInvalid.
           */
          default:
            qassert(false) ;

            bgp_connection_down(connection) ;

            eqb->note = bgp_note_new(BGP_NOMC_CEASE, BGP_NOMS_UNSPECIFIC) ;
            fsm_event = bgp_feInvalid ;
            break ;
        } ;

      break ;
    } ;

  /* If the Routeing Engine is waiting, and the buffer is not empty, kick.
   */
  if (rb_get_prompt(connection->read_rb, false /* not if empty */))
    bgp_session_kick_re_read(connection->session) ;

  /* If the reader is still brs_ok, make sure will continue reading if there
   * is space in the buffer.
   */
  bgp_msg_read_continue(reader, connection->qf) ;

  /* If we are returning no event at all, then have done all the I/O there is
   * to be done for the time being.
   */
  if (fsm_event == bgp_feNULL)
    connection->meta_events &= ~bgp_fmIO ;

  return fsm_event ;
} ;

