/* Configuration generator.
   Copyright (C) 2000 Kunihiro Ishiguro

This file is part of GNU Zebra.

GNU Zebra is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

GNU Zebra is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Zebra; see the file COPYING.  If not, write to the Free
Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */

#include "lib/misc.h"

#include "lib/command.h"
#include "lib/command_local.h"
#include "lib/list_util.h"
#include "lib/memory.h"
#include "lib/qpath.h"
#include "lib/pthread_safe.h"
#include "lib/qpath.h"
#include "lib/vhash.h"
#include "lib/elstring.h"
#include "lib/miyagi.h"

#include "vtysh/vtysh.h"
#include "lib/vty_vtysh_content.h"
#include "lib/vty_command.h"
#include "lib/vty_vtysh.h"
#include "lib/vty_io.h"

/*==============================================================================
 * Reading configuration from file and sending to all connected daemons.
 *
 *
 */

/*------------------------------------------------------------------------------
 * Read given configuration file & set host config directory and file name.
 *
 * If "required", report error if file not found.
 *
 * Returns: true <=> OK (includes file not found if !required)
 */
extern bool
vtysh_read_config(vty vtysh, qpath config_file, bool required,
                                                bool ignore_warnings,
                                                bool quiet)
{
  cmd_ret_t ret ;
  int conf_fd ;

  /* We start the process at the base level vin/vout, and will in a moment
   * push a VIN_CONFIG.  We treat the reading of config as a phantom top
   * level command -- so we are now vst_cmd_running_executing.
   */
  qassert((vtysh->vio->vin_depth == 1) && (vtysh->vio->vout_depth == 1)) ;

  vtysh->vio->state = vst_cmd_running_executing ;

  /* Do the standard configuration file open.
   *
   * Sets host.config_file/_dir in any event.
   *
   * Returns: -1 => hard error, -2 => not found
   */
  conf_fd = vty_open_config_file(vtysh, config_file, required) ;

  if (conf_fd == -2)            /* not found    */
    return !required ;

  if (conf_fd < 0)
    return false ;              /* hard error   */

  /* Opened OK, so hoover up the contents, starting in "configure terminal"
   * state, and dropping back to "enable" state afterwards.
   *
   * If we cannot start in "configure terminal", then does not read the
   * file and return failed.  NB: failure at this point is CMD_ERROR !
   *
   * For the vtysh we read configuration file by treating it as an input
   * file pipe.
   */
  if (!quiet)
    vty_out(vtysh, "Reading configuration file %s\n",
                                                    qpath_string(config_file)) ;

  vty_cmd_vtysh_config_prepare(vtysh, conf_fd, config_file, ignore_warnings,
                                                    false /* show_warnings */) ;

  ret = vty_vtysh_command_loop(vtysh, NULL, false /* not interactive */,
                                                0 /* no prompt */) ;
  return (ret == CMD_SUCCESS) ;
} ;

/*==============================================================================
 * Configuration store.
 *
 * Configuration files are generated by calling the "config_write" function
 * in each node that has one, in node number order.
 *
 * The nodes which have a "config write" are known as "configuration nodes".
 *
 * The integrated configuration file is built by reading configurations
 * generated by all the connected daemons, and merging where possible.
 *
 * The "#daemon" meta-command allows the integrated configuration to contain
 * commands which are only be used by the respective daemons.  This allows:
 *
 *   a) the integrated configuration file can be read directly by any
 *      daemon -- it does not need to be filtered by the vtysh.
 *
 *   b) common items, such as route-maps, do not need to be identical for
 *      all daemons.
 *
 *   c) when creating an integrated configuration file, each daemon's
 *      configuration is unaffected by any other daemons'.
 *
 * The creation of the integrated configuration file is, essentially a merge
 * of all the daemons' individual configurations.  The structure of the
 * configuration as output by each daemon is key to the merge and its
 * output:
 *
 *   a) each configuration "node" is separate.
 *
 *      The node is the top level configuration item.  A node may contain
 *      line, group and section items.  A group or section may contain further
 *      line, group and section items.
 *
 *      Any merging of configuration does not cross node/section/group
 *      boundaries, but will merge like node/section/group together, if
 *      possible.
 *
 *      The #vtysh-config-node, #vty-config-section and #vtysh-config-group
 *      meta-commands mark those boundaries.
 *
 *      Each group/section has a content_type, which may specify a "parser".
 *      If there is a parser, it examines each command line, and may identify
 *      a (possibly nested) implicit group/section structure -- in addition
 *      to any explicit structure.
 *
 *   b) the configuration is output in node number order.
 *
 *      There is an implied "NULL_NODE" at the start of the configuration,
 *      which carries ..... XXX .......................................................
 *
 *   c) the #vty-config-section and #vtysh-config-group meta-commands
 *      take two forms:
 *
 *        1. #vtysh-config-section 99 <content-type> <name...>
 *           #vtysh-config-group   99 <content-type> <name...>
 *
 *           where: 99 is the depth of the group/section -- 1..
 *
 *                  <content-type> is one of the vct_xxxx (other than vct_end)
 *
 *                  <name...>      is the name of the group/section
 *
 *           The enclosing node is implicitly depth == 0.
 *
 *           The depth must be 1..n, where n is <= current depth + 1.
 *
 *           These commands either create or re-enter the named section/group,
 *           see below.
 *
 *        2. #vtysh-config-section 99 end
 *           #vtysh-config-group   99 end
 *
 *           The depth must be 1..n, where n is <= current depth.
 *
 *           These commands end the given depth of group/section, returning to
 *           the parent group/section/node.
 *
 *   d) A section is a self contained piece of configuration, which has limited
 *      dependency on the rest of the node's configuration.
 *
 *      All command lines and groups in a given section are merged, and for
 *      some content types, sorted.  The result is a single section.
 *
 *      All sections are collected at the end of their parent node/section/
 *      group, sorted into section name order.
 *
 *      The simplest model is for all sections to be independent of each other,
 *      and any section may depend on other configuration in the parent -- but
 *      not vice versa.  However, dependency between sections may be controlled
 *      by manipulating the section name.
 *
 *   e) A group is also a self contained piece of configuration, which is
 *      required to retain its order wrt other groups and command lines,
 *      for each daemon.
 *
 *
 *   f) group and line items in a node/section/group either merge or sort.
 *
 *      Generally, the lines/groups in a group/section/node are "merged".
 *      The merging uses the "name" of the line/group.  For a line the "name"
 *      is the complete line.  For a group, the "name" is the group name.
 *      Lines and groups have separate name spaces.  Where two lines have the
 *      same name they will be merged provided that:
 *
 *         * the order of lines/groups for each daemon is preserved.
 *
 *         * repeated lines for a given daemon are retained.
 *
 *      Where two groups have the same name, they will be merged provided:
 *
 *         * the order of lines/groups for each daemon is preserved.
 *
 *      If the content type specifies it, the lines/groups in a group/section
 *      may be sorted, using the keys provided by the content type parser.
 *      Equal lines (by name, not by key) are merged, but if a given line
 *      repeats for some daemon, it will continue to repeat.  Equal groups
 *      (by name, not by key) will merge.  When the group/section is sorted,
 *      equal keys will sort into the original order.
 *
 *      In all cases, sections in a node/section/group are sorted wrt to each
 *      other, and sorted to the end of the parent node/section/group.
 *
 *      The basic merge will take:
 *
 *          daemon 1:
 *             item a
 *             item e
 *             item k
 *
 *          daemon 2:
 *             item b
 *             item d
 *             item b
 *             item k
 *
 *          daemon 3:
 *             item b
 *             item c
 *             item f
 *
 *      and produce:
 *
 *             item a  (1)
 *             item e  (1)
 *             item b  (2, 3)
 *             item d  (2)
 *             item b  (2)
 *             item c  (3)
 *             item k  (1, 2)
 *             item f  (3)
 *
 *      but if this is sorted, that will produce:
 *
 *             item a  (1)
 *             item b  (2, 3)
 *             item b  (2)
 *             item c  (3)
 *             item d  (2)
 *             item e  (1)
 *             item f  (3)
 *             item k  (1, 2)
 *
 *      NOTE: when each daemon outputs its configuration it does so in a
 *      fixed order.  This is KEY -- when merging nodes which contain
 *      configuration from two or more daemons, the lines and groups appear
 *      in the *same* order.  So any common parts can be found and merged
 *      *without* having to worry about whether the order is significant or
 *      not.
 *
 *      A sorted content type does not improve the ability to merge, but does
 *      improve the appearance of the result where there is a well known
 *      order.
 *
 * XXX ..................................................................................
 *
 *   d) the configuration may contain comments and separator lines.
 *
 *      A comment is a line whose first non-whitespace character is '!' or
 *      '#', and contains at least one non-whitespace character.
 *
 *      A separator line is one which contains only whitespace, or '!' or
 *      '#' and only whitespace.
 *
 *
 *
 *
 *      Comments are attached to the command line or group which they precede.
 *      Separators following a comment line are attached to the comment line.
 *
 *      Separators are attached to the command line, command group or comment
 *      line which they follow.  Multiple separators are merged together, and
 *      '#' takes precedence over '!' which takes precedence over empty.
 *
 *      When deciding whether to merge two command lines or groups, comment
 *      and whitespace is ignored.  When merging, any attached comments and/or
 *      separators are also merged.
 *
 *      When merging comments TODO......................................................
 *
 * XXX .................................................................................
 *
 *   e) At the start of each configuration is the "NULL" node, and at the end
 *      of each node is the NULL line.
 *
 *      Any comments at the end of a node are attached to a NULL line at the
 *      end of the node.  So any comments preceding the first node are attached
 *      to a NULL line at the end of the NULL node.
 *
 *      Any separators immediately following the start of a node are treated as
 *      separators following a phantom comment line.
 *
 *
 * XXX ..................................................................................
 *
 * When generating an integrated configuration, each attached daemon is asked
 * for its current configuration.  The first line of the configuration returned
 * by each daemon MUST be:
 *
 *    #vtysh-config-daemon DAEMON-NAME
 *
 * for the avoidance of doubt, and so that the configurations returned by all
 * daemons can be concatenated and then processed.
 */

/*------------------------------------------------------------------------------
 * Prototypes
 */
typedef struct config_item* config_item ;

static config_collection vtysh_config_collection_new(vty vtysh) ;
static void vtysh_config_own_config(vty vtysh) ;
static void vtysh_config_collect(vty vtysh, vio_fifo buf, const char* name) ;
static void vtysh_config_collect_existing(vty vtysh, vio_fifo fifo,
                                                          const char* name) ;
static cmd_ret_t vtysh_config_error(config_collection collection,
                                                          const char* message) ;

static cmd_ret_t vtysh_config_items_parse(config_collection collection) ;
static void vtysh_config_post_process(config_collection collection) ;
static config_item vtysh_config_node_find(config_collection collection,
                                                             node_type_t node) ;
static void vtysh_config_write_item(vty vtysh, config_item item) ;

/*------------------------------------------------------------------------------
 * Collect the integrated configuration
 *
 * Sets vty->collection to be the collection.
 */
extern cmd_ret_t
vtysh_config_collect_integrated(vty vtysh, bool show, qpath existing)
{
  cmd_ret_t   ret ;
  vio_fifo    obuf ;

  qassert(vtysh->collection == NULL) ;

  vtysh->collection = vtysh_config_collection_new(vtysh) ;

  /* Collect configuration from all client daemons
   */
  ret = vty_vtysh_fetch_config(vtysh, vtysh_config_collect, show) ;

  /* Make up the vtysh's own configuration, and collect same.
   *
   * For simplicity the vty_vtysh_own_config() writes to vty_out() in the
   * usual way.  But we here fix things so that the output actually goes to
   * the rbuf, which we collect for later.
   */
  obuf = vtysh->vio->obuf ;

  vtysh->vio->vout->obuf = vtysh->vio->obuf = vio_fifo_new(2048) ;

  vtysh_config_own_config(vtysh) ;
  vtysh_config_collect(vtysh, vtysh->vio->obuf, "vtysh") ;

  vio_fifo_free(vtysh->vio->obuf) ;
  vtysh->vio->vout->obuf = vtysh->vio->obuf = obuf ;

  obuf = NULL ;

  /* If an "existing" configuration file has been provided, try to open that,
   * and read it into another fifo.
   */
  if (existing != NULL)
    {
      int conf_fd ;

      conf_fd = vty_open_config_file(vtysh, existing,
                                                   false /* not "required" */) ;
      if (conf_fd < 0)
        {
          if (conf_fd == -1)
            ret = CMD_ERROR ;
        }
      else
        {
          int rc ;

          obuf = vio_fifo_new(32 * 1024) ;

          do
            rc = vio_fifo_read_nb(obuf, conf_fd, 0, 8) ;
          while (rc >= 0) ;

          if (rc == -1)
            {
              vty_out(vtysh, "%% failed to read existing %s: %s\n",
                                 qpath_string(existing), errtoa(errno, 0).str) ;
              ret = CMD_ERROR ;
            }
          else
            {
              if (show)
                vty_out(vtysh, "Read existing %s\n", qpath_string(existing)) ;

              vtysh_config_collect_existing(vtysh, obuf,
                                                       qpath_string(existing)) ;

              obuf = NULL ;
            } ;

          close(conf_fd) ;
        } ;
    } ;

  /* Process collected configuration into items
   */
  if (ret == CMD_SUCCESS)
    ret = vtysh_config_items_parse(vtysh->collection) ;

  /* If all is well, sort nodes/sections/groups of the now collected and merged
   * configuration, as required, .
   */
  if (ret == CMD_SUCCESS)
    vtysh_config_post_process(vtysh->collection) ;

  return ret ;
} ;

/*------------------------------------------------------------------------------
 * Blow the given integrated node configuration (if any) to the vtysh
 *
 * This is the call-back from vty_write_config_file().
 *
 * NB: depend on seeing NULL_NODE first.
 *
 * Returns: < 0 => nothing for the given node
 *            0 => do not add "!" separator
 *          > 0 => do add "!" separator
 */
extern int
vtysh_config_write_config_node(vty vtysh, node_type_t node)
{
  config_item section_item ;

  /* Find first section in the given node.
   */
  section_item = vtysh_config_node_find(vtysh->collection, node) ;

  if (section_item == NULL)
    return -1 ;

  /* Reset the collection->daemon and proceed to output all the secions in the
   * given node and all their children.
   */
  vtysh_config_write_item(vtysh, section_item) ;

  return 0 ;
} ;

/*==============================================================================
 * Configuration Nodes and Items
 *
 *
 */

/*------------------------------------------------------------------------------
 * The configuration, group and line items
 */
typedef struct dl_list_pair(config_item) config_item_ptrs_t ;

typedef struct dl_base_pair(config_item) config_item_base_t ;
typedef config_item_base_t* config_item_base ;

typedef enum                    /* types of config_item                 */
{
  it_null    = 0,

  it_node,
  it_section,
  it_group,
  it_line,

  it_comment,                   /* for comments lists only              */

} config_item_type_t ;

#if 0
typedef enum                    /* types of config_item                 */
{
  gt_null    = 0,

  gt_simple,
  gt_indented,

} config_group_type_t ;
#endif

typedef enum                    /* types of separator/comment line      */
{
  sep_none   = 0,

  sep_blank,
  sep_shriek,
  sep_hash,

  sep_shriek_comment,
  sep_hash_comment,

} config_sep_type_t ;

/* The name of an item, or items.
 *
 * The name includes the parent ordinal and the item_type of the item.  So all
 * names have their scope built into them.
 */
typedef struct config_name* config_name ;
typedef struct config_name  config_name_t ;

struct config_name
{
  vhash_node_t  vhash ;         /* */

  config_item   list ;          /* list of items with this name         */

  config_item_type_t type ;     /* separate name spaces                 */

  uint          ord ;           /* for it_node this is the node
                                 * for others this is the parent ordinal */

  uchar         str[1] ;        /* the name -- '\0' terminated          */
} ;

CONFIRM(offsetof(config_name_t, vhash) == 0) ;  /* see vhash.h  */

/* Context while parsing in vtysh_config_items_parse()
 */
typedef struct config_part*    config_part ;
typedef struct config_fagment* config_fragment ;


/*------------------------------------------------------------------------------
 * Configuration collection.
 */
typedef struct config_collection  config_collection_t ;

struct config_collection
{
  /* The vty to use if we need to report any errors in the input.
   */
  vty           vtysh ;

  /* The collection is a list of it_node -- the strategy for the collection is,
   * implicitly, mst_sorted.
   */
  config_item_base_t   config ;

  /* A single global symbol table is used for the names used for mst_as_is
   * merge strategy.  The name of an item includes its scope.
   */
  vhash_table  match ;

#if 0

  config_item   sep_item ;
  bool          sep_apply ;

  config_sep_type_t sep_pending ;
  daemon_set_t      sep_daemons ;
#endif

  /* As the configuration is collected, items are added to the current parent
   * item.  The parent item moves up and down the tree, driven by explicit
   * node/section/group meta-commands and implicit section/group changes
   * (produced by parsing the content of some types of section/group).
   */
  config_item     parent_item ;

  /* As the configuration is collected, keep track of what daemons the
   * configuration applies to.
   *
   * Each fresh configuration fetched from a connected daemon starts with a
   * #vtysh-config-daemon.  The daemon(s) specified are saved in daemon_new,
   * and subtracted from the daemons_mask on the next #vtysh-config-daemon.
   *
   * The daemons_mask is used to mask off all daemons we have fresh
   * configuration for -- particularly when processing the existing
   * configuration.
   */
  daemon_set_t  daemons ;               /* current daemons              */
  daemon_set_t  daemons_all ;           /* sum of all seen              */

  daemon_set_t  daemons_mask ;          /* daemons to accept in future  */
  daemon_set_t  daemon_new ;            /* current #vtysh-config-daemon */

  /* The following are used while reading and parsing the configuration
   */
  cmd_parsed    parsed ;

  elstring_t    line ;
  uint          ordinal ;

  vtysh_content_parse_t content[1] ;

  /* The following are used to store the raw configuration either as read from
   * the daemons and/or as read from a configuration file.
   *
   * The part list is a list of fifos containing the lines of configuration
   * read from a single daemon or configuration file.
   *
   * As the raw stuff is parsed into items, each item has an elstring which
   * point into the relevant fifo lump, or into a fragment -- for lines which
   * span two (or more !) fifo lumps.
   */
  config_part  part ;           /* used to step through parts           */

  struct dl_base_pair(config_part) part_list ;

  config_fragment fragment_list ;

  config_item_base_t comments ; /* current outstanding comments            */

  bool          existing ;      /* processing the existing configuration   */

  /* Working qstrings
   */
  qstring_t    temp ;           /* used when creating fragments         */
  qstring_t    comment ;        /* used when creating comment names     */

  /* Working vector for sorting items and collecting bubbles
   */
  vector       hat ;            /* used in vtysh_config_list_sort       */
} ;

/*------------------------------------------------------------------------------
 * Configuration item
 */
typedef struct config_item  config_item_t ;

struct config_item
{
  config_item           parent ;        /* NULL for it_section          */

  /* All items live on their parent's children list.
   */
  config_item_ptrs_t    siblings ;

  /* All items have a item_type, an ordinal and a set of daemons that the item
   * applies to.
   */
  config_item_type_t    item_type ;

  uint                  ordinal ;

  daemon_set_t          daemons ;

  /* For it_node, we have its item_type.
   */
  node_type_t           node ;

  /* For it_section and it_group, we have its content_type.
   *
   * The content_type specifies:
   *
   *   a) the parser (if any) for the group/section
   *
   *   b) whether the line/group children (if any) are to have keys, and be
   *      sorted by those keys.
   */
  vtysh_content_t       content_type ;
  bool                  content_sorted ;
  vtysh_content_func*   content_parser ;

  /* The line as input and, if required, output.
   *
   * This is an embedded elstring, which points into the raw lines stored in
   * the input "part" fifos etc.  This MUST be treated as "const".
   *
   * The embedded elstring's body may be NULL, signifying an absent line item.
   * Note that blank lines have a non-NULL elstring body.
   */
  elstring_t            line ;

  /* Where the parent's merge strategy is not mst_none, an item will have a
   * name.  The name is an entry in the collection's global name table.
   *
   * Where the item's name is not unique, the "also" pointer is used, and
   * points to the next item with the same name -- where that will be an
   * *earlier* item.
   */
  config_name           name ;
  config_item           also ;          /* next item with same name     */

  /* Where the parent's merge strategy is mst_sorted, a it_line item will have
   * a key.  The key is held in the collection's global key table.
   *
   * The key is a string, to be compared using strcmp_mixed().
   */
  const char*           key ;

  /* Where an item has line/group children, there is a list of those.  If the
   * content type specifies it, the children can be sorted.
   *
   * Where an item has subsections, there is a separate list of those.
   */
  config_item_base_t    children ;
  config_item_base_t    subsections ;

  /* For it_node and it_group, and it_line if an item is merged with another in
   * the children list, then "merged_item" is where the merge occurred, and
   * "merged_daemons" is the daemons for the item that was merged in (not the
   * daemons for the result.
   *
   * If there is a merged_item, then it is possible to:
   *
   *   a) append separator lines to it -- so the separator lines remain with
   *      the item they follow.
   *
   *   b) search *forwards* from this point for possible future merges.
   *
   * *provided* the merged_deamons *exactly* match the current daemons.
   *
   * As soon as a new item is appended to the children list, the merged_item
   * pointer is cleared.
   */
  config_item           merged_item ;
  daemon_set_t          merged_daemons ;

  /* For it_comment -- the item_type of comment line.
   */
  config_sep_type_t     ctype ;
} ;

/*------------------------------------------------------------------------------
 * Prototypes
 */
static void vtysh_config_list_free(config_item parent,
                                                     config_item_base_t* base) ;
static bool vtysh_config_collect_next_line(config_collection collection) ;
static void vtysh_config_collect_first_part(config_collection collection) ;
static void vtysh_config_collect_next_part(config_collection collection);
static void vtysh_config_raw_free(config_collection collection) ;

static cmd_ret_t vtysh_config_parse_comment(config_collection collection) ;
static cmd_ret_t vtysh_config_parse_daemon(config_collection collection,
                                                              bool reset_node) ;
static cmd_ret_t vtysh_config_parse_node(config_collection collection) ;
static cmd_ret_t vtysh_config_parse_section(config_collection collection) ;

#if 0
static cmd_ret_t vtysh_config_parse_group(config_collection collection,
                                                               uint max_depth) ;
static cmd_ret_t vtysh_config_parse_group_end(config_collection collection) ;
#endif

static cmd_ret_t vtysh_config_parse_line(config_collection collection) ;

static cmd_ret_t vtysh_config_node_set(config_collection collection,
                                                             node_type_t node) ;
static config_name vtysh_config_make_name(config_collection collection,
                                            config_item_type_t item_type,
                                               uint ordinal, qstring raw_name) ;

static vhash_hash_func   vtysh_config_name_hash ;
static vhash_equal_func  vtysh_config_match_equal ;
static vhash_new_func    vtysh_config_match_new ;
static vhash_free_func   vtysh_config_match_free ;

static vhash_params_t vtysh_config_match_params =
  {
    .hash   = vtysh_config_name_hash,
    .equal  = vtysh_config_match_equal,
    .new    = vtysh_config_match_new,
    .free   = vtysh_config_match_free,
    .orphan = vhash_orphan_null,
  } ;

static cmd_ret_t vtysh_config_item_insert(config_collection collection) ;
static config_item vtysh_config_item_new(config_collection collection,
   config_item parent, config_item_type_t it, config_name name, elstring line) ;

static config_item vtysh_config_parent_item_close(config_collection collection);

static void vtysh_config_write_comments(vty vtysh, config_item item) ;
static void vtysh_config_write_children(vty vtysh, config_item item) ;
static void vtysh_config_write_line(vty vtysh, config_item item) ;
static void vtysh_config_write_post_sep(vty vtysh, config_item item) ;
static void vtysh_config_write_daemons(vty vtysh, daemon_set_t daemons) ;

static void vtysh_config_proc_list(config_collection collection,
                                          config_item_base_t* base, bool sort) ;
static void vtysh_config_list_sort(config_collection collection,
                              config_item_base_t* base, config_item_type_t it) ;

/*------------------------------------------------------------------------------
 * Create a new config_collection
 */
static config_collection
vtysh_config_collection_new(vty vtysh)
{
  config_collection collection ;

  collection = XCALLOC(MTYPE_TMP, sizeof(config_collection_t)) ;

  /* Zeroising sets:
   *
   *   vtysh           -- X          -- set below
   *
   *   config          -- NULLs      -- empty list
   *
   *   match           -- X          -- set below
   *
   *   parent_item     -- NULL       -- none, yet
   *
   *   daemons         -- 0          -- none, yet
   *   daemons_all     -- 0          -- none, yet
   *   daemons_mask    -- 0          -- none, yet
   *   daemon_new      -- 0          -- none, yet
   *
   *   parsed          -- NULL       -- none, yet
   *   line            -- unset elstring (embedded)
   *   ordinal         -- 0
   *   content         -- all zero   -- set, below
   *
   *   part            -- NULL       -- nothing yet
   *
   *   part_list       -- NULLs      -- empty
   *   fragment_list   -- NULL       -- empty
   *
   *   comments        -- NULLs      -- empty list of outstanding comment lines
   *   existing        -- false      -- not processing existing config
   *
   *   temp            -- unset qstring (embedded)
   *   comment         -- unset qstring (embedded)
   *
   *   hat             -- X          -- set below
   */
  confirm(ELSTRING_INIT_ALL_ZEROS) ;
  confirm(QSTRING_UNSET_ALL_ZEROS) ;
  confirm(sep_none  == 0) ;

  collection->vtysh = vtysh ;

  collection->content->line_key  = qs_new(100) ;
  collection->content->group_key = qs_new(100) ;
  collection->content->new_name  = qs_new(100) ;

  collection->match = vhash_table_new(NULL, 2000, 200,
                                                    &vtysh_config_match_params) ;

  collection->hat = vector_new(200) ;

  return collection ;
} ;

/*------------------------------------------------------------------------------
 * Free given config_collection (if any) and all its contents
 *
 * Returns:  NULL
 */
extern void
vtysh_config_collection_free(vty vtysh)
{
  config_collection collection ;

  collection = vtysh->collection ;

  if (collection == NULL)
    return ;

  /* Ream out the symbol table and free it.  All names are discarded later.
   */
  collection->match = vhash_table_reset(collection->match, free_it) ;

  /* Ream out all the node items, and all their children etc.
   */
  vtysh_config_list_free(NULL, &collection->config) ;

  /* Finished with the parser too -- if any still there
   */
  collection->parsed = cmd_parsed_free(collection->parsed) ;

  /* Finished with the content stuff.
   */
  qs_free(collection->content->line_key) ;
  qs_free(collection->content->group_key) ;
  qs_free(collection->content->new_name) ;

  /* Discard all the raw lines -- includes all the fragments, where all item
   * names are held.
   */
  vtysh_config_raw_free(collection) ;

  /* Discard any sorting vector
   */
  collection->hat = vector_free(collection->hat) ;

  /* All done
   */
  XFREE(MTYPE_TMP, collection) ;

  vtysh->collection = NULL ; ;
} ;

/*------------------------------------------------------------------------------
 * Read configuration into items...
 *
 * The fist line in any daemon's configuration *must* be the #daemon line.
 */
static cmd_ret_t
vtysh_config_items_parse(config_collection collection)
{
  cmd_ret_t   ret ;
  qstring_t   qs ;

  ret = CMD_SUCCESS ;           /* so far, so good      */

  /* Prepare to parse the configuration lines into the collection.
   *
   * Note that we start in the NULL_NODE -- creating same if does not exist.
   */
  qs_init_new(qs, 0) ;

  if (collection->parsed == NULL)
    collection->parsed = cmd_parsed_new() ;

  vtysh_config_node_set(collection, NULL_NODE) ;

  /* Initialise the daemons and the part state for the start of the first
   * part.
   *
   * Note that each part is initialised, ready to read the first line.
   *
   * The ...
   */
  collection->daemons_mask = ALL_RDS | VTYSH_VD ;
  collection->daemons      = collection->daemons_mask ;
  collection->daemon_new   = 0 ;

  vtysh_config_collect_first_part(collection) ;

  while ((collection->part != NULL) && (ret == CMD_SUCCESS))
    {
      cmd_token   t ;

      if (!vtysh_config_collect_next_line(collection))
        {
          /* We are at the end of the current part, so reset the daemons state.
           *
           * The configuration from a connected daemon starts with a
           * #vtysh-config-daemon, which sets the daemon_new state.  Now that
           * the configuration for that daemon is complete, we add that daemon
           * to the set of daemons to collect no further configuration for.
           *
           * The current daemons is reset to all daemons we can still collect
           * for.
           */
          collection->daemons_mask &= ~collection->daemon_new ;
          collection->daemon_new    = 0 ;

          collection->daemons = collection->daemons_mask ;

          /* Reset to the NULL_NODE, between parts and after the last part
           */
          vtysh_config_node_set(collection, NULL_NODE) ;

          /* Step to the next part and loop to collect the first line, or
           * notice we have reached the end of the collections' parts.
           */
          vtysh_config_collect_next_part(collection) ;

          continue ;
        } ;

      /* We tokenise each line so that we know exactly what we are dealing with
       */
      qs_set_els(qs, collection->line) ;
      cmd_tokenize(collection->parsed, qs, false /* not full_lex */) ;

      /* Need to identify:
       *
       *   meta commands:
       *
       *   comments and blank lines
       *
       *   other stuff
       */
      t = cmd_token_get(collection->parsed->tokens, 0) ;

      switch (t->type)
        {
          /* Blank separator line or comment.
           */
          case cmd_tok_eol:
          case cmd_tok_comment:
            if (collection->daemons == 0)
              break ;

            ret = vtysh_config_parse_comment(collection) ;
            break ;

          /* Start next daemon/node/section
           */
          case cmd_tok_meta_prefix:
            t = cmd_token_get(collection->parsed->tokens, 1) ;

            if      (els_cmp_str(t->ot, "vtysh-config-daemon") == 0)
              ret = vtysh_config_parse_daemon(collection,
                                         true  /* vtysh-config-daemon */) ;

            else if (els_cmp_str(t->ot, "vtysh-config-node") == 0)
              ret = vtysh_config_parse_node(collection) ;

            else if (els_cmp_str(t->ot, "vtysh-config-section") == 0)
              ret = vtysh_config_parse_section(collection) ;

            else if (els_cmp_str(t->ot, "vtysh-config-group") == 0)
#if 0
              ret = vtysh_config_parse_group(collection, -1) ;
#else
              ret = CMD_SUCCESS ;
#endif
            else if (els_cmp_str(t->ot, "vtysh-config-group-simple") == 0)
#if 0
              ret = vtysh_config_parse_group(collection, 0) ;
#else
              ret = CMD_SUCCESS ;
#endif
            else if (els_cmp_str(t->ot, "vtysh-config-group-indent-1") == 0)
#if 0
              ret = vtysh_config_parse_group(collection, 1) ;
#else
              ret = CMD_SUCCESS ;
#endif
            else if (els_cmp_str(t->ot, "vtysh-config-group-indent-2") == 0)
#if 0
              ret = vtysh_config_parse_group(collection, 2) ;
#else
              ret = CMD_SUCCESS ;
#endif
            else if (els_cmp_str(t->ot, "vtysh-config-group-end") == 0)
#if 0
              ret = vtysh_config_parse_group_end(collection) ;
#else
              ret = CMD_SUCCESS ;
#endif

            else if ( (els_cmp_str(t->ot, "daemon")  == 0)
                   || (els_cmp_str(t->ot, "daemons") == 0) )
              ret = vtysh_config_parse_daemon(collection,
                                         false  /* not vtysh-config-daemon */) ;
            else
              ret = vtysh_config_error(collection,
                                                  "unknown meta command line") ;
            break ;

          case cmd_tok_simple:
            if (collection->daemons == 0)
              break ;

            ret = vtysh_config_parse_line(collection) ;
            break ;

          default:
            ret = vtysh_config_error(collection, "unknown initial token type") ;
            break ;
        } ;
    } ;

  /* Tidy up
   */
  collection->parsed = cmd_parsed_free(collection->parsed) ;
  qs_reset(qs, keep_it) ;               /* discard the body only        */

  return ret ;
} ;

/*------------------------------------------------------------------------------
 * Process all nodes and all groups/sections, sorting as required, and
 * appending each item's sorted subsections to its children.
 *
 * Once an integrated configuration has been collected and merged, the final
 * step is to sort:
 *
 *   1) the top, collection->config level, by node number
 *
 *   2) any sections/groups whose content is to be sorted
 *
 *   3) all subsections of all nodes/sections/groups
 *
 * Appends subsection lists to the related children list, so that all an item's
 * child items are on the one list.
 */
static void
vtysh_config_post_process(config_collection collection)
{
  vtysh_config_proc_list(collection, &(collection->config), true /* sort */) ;
} ;

/*------------------------------------------------------------------------------
 * Process given list -- sort if required, then process children and
 * subsections, appending (sorted) subsections to children.
 */
static void
vtysh_config_proc_list(config_collection collection, config_item_base_t* base,
                                                                      bool sort)
{
  config_item        item ;

  item = ddl_head(*base) ;

  if (item == NULL)
    return ;

  if (sort)
    {
      /* Sort the given list.
       */
      vtysh_config_list_sort(collection, base, item->item_type) ;
      item = ddl_head(*base) ;
    } ;

  do
    {
      /* Process the children and subsections, sorting them as required, and
       * then processing their children and subsections.
       *
       * Then stick the subsections onto the back of the children -- so end
       * up with one list.
       */
      vtysh_config_proc_list(collection, &(item->children),
                                                         item->content_sorted) ;
      vtysh_config_proc_list(collection, &(item->subsections),
                                                              true /* sort */) ;

      ddl_append_list(item->children, item->subsections, siblings) ;
      ddl_init(item->subsections) ;

      item = ddl_next(item, siblings) ;
    }
  while (item != NULL) ;
} ;

/*------------------------------------------------------------------------------
 * We have an empty or comment line.
 *
 * Establish what sort of comment line it is, and append it to the current
 * collection for disposition.
 */
static cmd_ret_t
vtysh_config_parse_comment(config_collection collection)
{
  cmd_token   t ;
  config_item comment_item ;
  config_sep_type_t sep ;

  t = cmd_token_get(collection->parsed->tokens, 0) ;

  if ((t->type == cmd_tok_eol) || (els_len_nn(t->ot) == 0))
    sep   = sep_blank ;
  else
    {
      bool empty ;

      qassert(t->type == cmd_tok_comment) ;
      qassert(els_len_nn(t->ot) > 0) ;

      empty = (els_len_nn(t->ot) <= 1) ;

      switch (*((char*)els_body_nn(t->ot)))
        {
          case '!':
            sep = empty ? sep_shriek : sep_shriek_comment ;
            break ;

          case '#':
            sep = empty ? sep_hash   : sep_hash_comment ;
            break ;

          default:
            return vtysh_config_error(collection, "unknown comment line") ;
      } ;
    } ;

  qassert(els_body_nn(collection->line) != NULL) ;

  comment_item = vtysh_config_item_new(collection, NULL /* no parent */,
                             it_comment, NULL /* no name */, collection->line) ;

  comment_item->ctype = sep ;

  ddl_append(collection->comments, comment_item, siblings) ;

  return CMD_SUCCESS ;
} ;

#if 0
/*------------------------------------------------------------------------------
 * Apply any sep_pending to the current sep_item.
 */
static void
vtysh_config_do_apply_sep(config_collection collection)
{
  assert(collection->sep_item != NULL) ;

  if (collection->sep_daemons != 0)
    {
      if (collection->sep_item->post_sep < collection->sep_pending)
        collection->sep_item->post_sep = collection->sep_pending ;

      collection->sep_item->post_sep_daemons |= collection->sep_daemons ;
    } ;

  collection->sep_pending = sep_none ;
  collection->sep_daemons = 0 ;
} ;

/*------------------------------------------------------------------------------
 * Set the sep_item and allow any following separator(s) to be applied
 * immediately.
 */
static void
vtysh_config_apply_sep(config_collection collection, config_item item)
{
  assert(item != NULL) ;

  collection->sep_item  = item ;
  collection->sep_apply = true ;

  if (collection->sep_daemons != 0)
    {
      if (item->post_sep < collection->sep_pending)
        item->post_sep = collection->sep_pending ;

      item->post_sep_daemons |= collection->sep_daemons ;
    } ;

  collection->sep_pending = sep_none ;
  collection->sep_daemons = 0 ;
} ;

/*------------------------------------------------------------------------------
 * Set the sep_item but do not allow any following separator(s) to be applied
 * immediately.
 */
static void
vtysh_config_defer_sep(config_collection collection, config_item item)
{
  assert(item != NULL) ;

  collection->sep_item  = item ;
  collection->sep_apply = false ;
} ;

#endif

/*------------------------------------------------------------------------------
 * We have a #vtysh-config-daemon. #daemons or #daemon line.
 *
 * Identify the daemon(s) and set collection->daemon, which defines what
 * daemons any following items apply to.
 *
 * If this is #vtysh-config-daemon, then this:
 *
 *   * updates the collection->daemons_mask to exclude any current
 *     collection->daemon_new
 *
 *   * sets the new collection->daemon_new
 *
 *   * resets the current node to the NULL_NODE and closes any current
 *     section.
 *
 * NB: having more than one #vtysh-config-daemon for the same daemon would
 *     mean have received stuff from the same connected daemon twice.
 *
 *     We do not output #vtysh-config-daemon lines, but for testing purposes
 *     they can appear in input file(s) -- subject to there being at most one
 *     #vtysh-config-daemon for each daemon in one collection.
 *
 * In all cases, we discount the (now) current collection->daemons_mask.
 */
static cmd_ret_t
vtysh_config_parse_daemon(config_collection collection,
                                                       bool vtysh_config_daemon)
{
  qstring      list ;
  daemon_set_t daemons ;
  cmd_ret_t    ret ;

  ret = CMD_SUCCESS ;

  /* The qstring returned resides in the collection->parsed structure, so must
   * not be released when we are done here.
   */
  list = cmd_tokens_concat(collection->parsed, 2,
                                           collection->parsed->num_tokens - 2) ;
  daemons = cmd_daemons_from_list(list) ;

  if (qs_len(list) == 0)
    {
      if (daemons == 0)
        ret = vtysh_config_error(collection, "empty list of daemons") ;
    }
  else
    {
      ret = vtysh_config_error(collection, "one or more invalid daemons") ;
      daemons = 0 ;
    } ;

  if (vtysh_config_daemon && (ret == CMD_SUCCESS))
    {
      collection->daemons_mask &= ~collection->daemon_new ;
      collection->daemon_new    = daemons ;

      /* If we are not processing the existing integrated configuration, it is
       * an error to find that we have already received the configuration for
       * the current daemons.
       */
      if (collection->existing ||
          ( (collection->daemon_new & collection->daemons_mask) ==
                                                       collection->daemon_new ))
        ret = vtysh_config_node_set(collection, NULL_NODE) ;
      else
        ret = vtysh_config_error(collection, "repeat #vtysh-config-daemon") ;

    } ;

  collection->daemons = daemons & collection->daemons_mask ;

  return ret ;
} ;

/*------------------------------------------------------------------------------
 * We have a node line:
 *
 *   #vtysh-config-node NODE-NAME
 *
 * Identify the node and set it.
 */
static cmd_ret_t
vtysh_config_parse_node(config_collection collection)
{
  qstring tmp ;
  node_type_t node ;
  cmd_ret_t ret ;

  if (collection->parsed->num_tokens != 3)
    return vtysh_config_error(collection, "invalid #vtysh-config-node") ;

  tmp = NULL ;

  tmp = qs_set_els(tmp, cmd_token_get(collection->parsed->tokens, 2)->ot) ;
  node = cmd_node_by_name(qs_string(tmp)) ;

  if (node != NULL_NODE)
    ret = vtysh_config_node_set(collection, node) ;
  else
    ret = vtysh_config_error(collection, "unknown node or section type") ;

  qs_free(tmp) ;

  return ret ;
} ;

/*------------------------------------------------------------------------------
 * We have an explicit section start:
 *
 *   #vtysh-config-section <depth> CONTENT-TYPE [.SECTION-NAME]
 *
 * Identify the section item_type and section name.  No section name if
 * is the pseudo-type "end".
 *
 * Close any existing parent and set item_type and name ready to open a new
 * section, if required.
 */
static cmd_ret_t
vtysh_config_parse_section(config_collection collection)
{
  vtysh_content_parse content ;
  uint        nt ;
  const char* end ;
  strtox_t    tox ;

  content = collection->content ;

  /* The leading "#" counts as a token, and the section name may be empty !
   */
  nt = collection->parsed->num_tokens ;

  if (nt < 4)
    return vtysh_config_error(collection, "invalid #vtysh-config-section") ;

  /* Parse and check the section depth, content_type and name.
   *
   * Sets:  content->new_depth
   *               ->new_type
   *               ->new_name
   */
  qs_set_els(content->new_name,
                             cmd_token_get(collection->parsed->tokens, 2)->ot) ;
  content->new_depth = strtol_xr(qs_string(content->new_name),
                                                            &tox, &end, 1, 99) ;

  if ((tox != strtox_ok) || (*end != '\0'))
    return vtysh_config_error(collection, "invalid or out of range depth") ;

  qs_set_els(content->new_name,
                             cmd_token_get(collection->parsed->tokens, 3)->ot) ;
  content->new_type = vtysh_content_type(qs_string(content->new_name)) ;

  if (content->new_type == vct_unknown)
    return vtysh_config_error(collection, "unknown section type") ;

  if ((content->new_type == vct_end) && (nt != 4))
    return vtysh_config_error(collection, "name after 'end'") ;

  qs_set(content->new_name, cmd_tokens_concat(collection->parsed, 4, nt - 4)) ;

  /* Have new section parameters.
   */
  content->result = vcp_meta_line | vcp_section ;

  return vtysh_config_item_insert(collection) ;
} ;

#if 0


/*------------------------------------------------------------------------------
 * We have a "#vtysh-config-group-simple" or "#vtysh-config-group-indent_X".
 *
 * The entire line is saved for eventual output.
 *
 * If the max_depth is 0 (ie "#vtysh-config-group-simple") sets the gtype to
 * gt_simple, otherwise sets gt_indented with the given max_depth.
 */
static cmd_ret_t
vtysh_config_parse_group(config_collection collection, uint max_depth)
{
  config_item group ;

  group = vtysh_config_item_insert(collection, it_group, collection->line) ;

  if (max_depth == 0)
    group->gtype  = gt_simple ;
  else
    group->gtype  = gt_indented ;

  group->max_depth = max_depth ;

  collection->parent_item = group ;

  return CMD_SUCCESS ;
} ;

/*------------------------------------------------------------------------------
 * We have a group end line, so "close" the current group.
 *
 * The group will be the current collection->parent_item -- after closing any
 * it_line/gt_indented line groups.
 */
static cmd_ret_t
vtysh_config_parse_group_end(config_collection collection)
{
  config_item parent ;

  parent = collection->parent_item ;

  assert(parent != NULL) ;

  while ((parent->item_type == it_line) && (parent->gtype == gt_indented))
    parent = vtysh_config_parent_item_close(collection) ;

  if (parent->item_type != it_group)
    return vtysh_config_error(collection, "unexpected group end") ;

  vtysh_config_parent_item_close(collection) ;

  return CMD_SUCCESS ;
} ;
#endif

/*------------------------------------------------------------------------------
 * We have a command line.
 */
static cmd_ret_t
vtysh_config_parse_line(config_collection collection)
{
  vtysh_content_parse content ;
  config_item parent ;

  content = collection->content ;
  parent  = collection->parent_item ;

  if (parent->content_parser == NULL)
    {
      qassert(!parent->content_sorted) ;
      content->result = vcp_line ;
    }
  else
    {
      cmd_ret_t ret ;

      ret = parent->content_parser(content, collection->parsed) ;

      if (ret != CMD_SUCCESS)
        return vtysh_config_error(collection, content->error_msg) ;
    } ;

  return vtysh_config_item_insert(collection) ;
} ;

/*------------------------------------------------------------------------------
 * Write away the given item, with any pre_comments, children and post_sep.
 */
static void
vtysh_config_write_item(vty vtysh, config_item item)
{
  switch (item->item_type)
    {
#if 0
      case it_dummy:
        /* Should not be any dummy items at this stage
         */
        qassert(false) ;
        break ;
#endif

      case it_node:
        /* Reset the daemons state between nodes.
         */
        vtysh->collection->daemons = 0 ;

        /* If the node has no children, we can ignore it altogether.
         */
        if (ddl_head(item->children) == NULL)
          break ;

        /* If not NODE_NULL, output vtysh-config-node NODE-NAME
         */
        if (item->node != NULL_NODE)
          vty_out(vtysh, "#vtysh-config-node %s\n", cmd_node_name(item->node)) ;

        /* Process all children of this node
         */
        vtysh_config_write_children(vtysh, item) ;

        break ;

#if 0
      case it_empty:
        /* Process pre-comments
         */
        vtysh_config_write_comments(vtysh, item) ;

        /* There should be no line (it's empty !).
         */
        qassert(els_body_nn(item->line) == NULL) ;

        /* No post-separator -- will have been attached to it_comment line.
         */
        qassert(item->post_sep == sep_none) ;

        /* No children !
         */
        qassert(ddl_head(item->children) == NULL) ;

        break ;
#endif

      case it_section:
  #if 0
        /* Never attaches pre-comments to an it_section.
         */
        qassert(ddl_head(item->pre_comments) == NULL) ;
  #endif

        /* If there is a #vtysh-config-section line, output that.
         */
        vtysh_config_write_line(vtysh, item) ;

  #if 0
        /* Never attaches post-separators to an it_section.
         */
        qassert(item->post_sep == sep_none) ;
  #endif

        /* Process the children
         */
        vtysh_config_write_children(vtysh, item) ;

        break ;

      case it_group:
  #if 0
        /* Never attaches pre-comments to an it_section.
         */
        qassert(ddl_head(item->pre_comments) == NULL) ;
  #endif

        /* If there is a #vtysh-config-group line, output that.
         */
        vtysh_config_write_line(vtysh, item) ;

  #if 0
        /* Never attaches post-separators to an it_section.
         */
        qassert(item->post_sep == sep_none) ;
  #endif

        /* Process the children
         */
        vtysh_config_write_children(vtysh, item) ;

        break ;

      case it_line:
  #if 0
        /* Process pre-comments
         */
        vtysh_config_write_comments(vtysh, item) ;
  #endif

        /* The line itself
         */
        if (item->daemons != 0)
          {
            if (vtysh->collection->daemons != item->daemons)
              vtysh_config_write_daemons(vtysh, item->daemons) ;
            vtysh_config_write_line(vtysh, item) ;
          } ;

  #if 0
        /* Process any post-separator
         */
        vtysh_config_write_post_sep(vtysh, item) ;

        /* No children !
         */
        qassert(ddl_head(item->children) == NULL) ;
  #endif

        break ;

      case it_comment:
  #if 0
        /* Never attaches pre-comments to an it_comment.
         */
        qassert(ddl_head(item->pre_comments) == NULL) ;

        /* Output the comment line
         */
        if (item->daemons != 0)
          {
            if (vtysh->collection->daemons != item->daemons)
              vtysh_config_write_daemons(vtysh, item->daemons) ;
            vtysh_config_write_line(vtysh, item) ;
          } ;

        /* Process any post-separator
         */
        vtysh_config_write_post_sep(vtysh, item) ;

        /* No children !
         */
        qassert(ddl_head(item->children) == NULL) ;
  #endif
        break ;

      default:
        zabort("unknown item type") ;
    } ;
} ;

/*------------------------------------------------------------------------------
 * Write away the given item's pre_comments list.
 */
static void
vtysh_config_write_comments(vty vtysh, config_item item)
{
#if 0
  config_item comment ;

  comment = ddl_head(item->pre_comments) ;

  while (comment != NULL)
    {
      qassert(comment->item_type == it_comment) ;

      vtysh_config_write_item(vtysh, comment) ;

      comment = ddl_next(comment, siblings) ;
    } ;
#endif
} ;

/*------------------------------------------------------------------------------
 * Write away the given item's children.
 */
static void
vtysh_config_write_children(vty vtysh, config_item item)
{
  config_item child ;

  child = ddl_head(item->children) ;

  while (child != NULL)
    {
      vtysh_config_write_item(vtysh, child) ;

      child = ddl_next(child, siblings) ;
    } ;
} ;

/*------------------------------------------------------------------------------
 * Write away the item->line -- if any.
 *
 * NB: does not check for daemon state.
 */
static void
vtysh_config_write_line(vty vtysh, config_item item)
{
  if (els_body_nn(item->line) != NULL)
    {
      qstring temp = vtysh->collection->temp ;

      qs_set_els(temp, item->line) ;
      vty_out(vtysh, "%s\n", qs_string(temp)) ;
    } ;
} ;

/*------------------------------------------------------------------------------
 * Write away the item->post_separators -- if any -- dealing with daemon state.
 */
static void
vtysh_config_write_post_sep(vty vtysh, config_item item)
{
#if 0
  if ((item->post_sep != sep_none) && (item->post_sep_daemons != 0))
    {
      if (vtysh->collection->daemons != item->post_sep_daemons)
        vtysh_config_write_daemons(vtysh, item->post_sep_daemons) ;

      switch (item->post_sep)
        {
          case sep_none:
            break ;

          case sep_blank:
            vty_out(vtysh, "\n") ;
            break ;

          case sep_shriek:
            vty_out(vtysh, "!\n") ;
            break ;

          case sep_hash:
            vty_out(vtysh, "#\n") ;
            break ;

          default:
            qassert(false) ;
            break ;
        } ;
    } ;
#endif
} ;

/*------------------------------------------------------------------------------
 * Update daemon state, if required.
 *
 * Write any #daemons required to bring collection->daemons up to date with
 * the given daemons.
 */
static void
vtysh_config_write_daemons(vty vtysh, daemon_set_t daemons)
{
  if (vtysh->collection->daemons != daemons)
    {
      qstring  list ;

      list = cmd_daemons_make_list(NULL, daemons) ;
      vty_out(vtysh, "#daemons %s\n", qs_string(list)) ;

      qs_free(list) ;

      vtysh->collection->daemons = daemons ;
    } ;
} ;

/*==============================================================================
 * Node handling
 */

/*------------------------------------------------------------------------------
 * Set the given node as the current node for the given collection, close any
 * current parent.
 *
 * Creates an item for the node, if this is the first time we have seen it.
 *
 * Sets the current parent to be the node.
 */
static cmd_ret_t
vtysh_config_node_set(config_collection collection, node_type_t node)
{
  config_item item ;

  /* Close current parent, if any.
   */
  if (collection->parent_item != NULL)
    {

    } ;

  /* Find the node_item for the node.
   */
  item = vtysh_config_node_find(collection, node) ;

  if (item == NULL)
    {
      /* Create a new node item of the given stype.
       */
      config_name name ;

      name = vtysh_config_make_name(collection, it_node, node,
                                                  NULL /* empty name string*/) ;
      item = vtysh_config_item_new(collection, NULL /* no parent */, it_node,
                                                       name, collection->line) ;

      item->node = node ;

      ddl_append(collection->config, item, siblings) ;
    } ;

  /* Set the parent item an reset the depth.
   */
  collection->parent_item    = item ;
  collection->content->depth = 0 ;

  return CMD_SUCCESS ;
} ;

/*------------------------------------------------------------------------------
 * Find the given node, if it is present.
 */
static config_item
vtysh_config_node_find(config_collection collection, node_type_t node)
{
  config_name_t temp[1] ;
  config_name   name ;
  config_item   item ;

  temp->type   = it_node ;
  temp->ord    = node ;
  temp->str[0] = '\0' ;

  name = vhash_lookup(collection->match, temp, NULL) ;

  if (name == NULL)
    return NULL ;

  item = name->list ;

  qassert(item->item_type == it_node) ;
  qassert(item->node == node) ;
  qassert(item->name == name) ;

  return item ;
} ;

/*==============================================================================
 * Item Handling -- insertion and merging
 */
static config_item vtysh_config_merge_try(config_collection collection,
                                                           config_item parent,
                                                           config_item target) ;
static config_item vtysh_config_merge_try_down(config_collection collection,
                                       config_item parent, config_item target) ;
static config_item vtysh_config_merge_try_up(config_collection collection,
                                    config_item_base list, config_item target) ;



static void vtysh_config_merge_comment(config_collection collection,
                                       config_item target, config_item source) ;
static int vtysh_config_cmp_nodes(const cvp* pa, const cvp* pb) ;
static int vtysh_config_cmp_sections(const cvp* pa, const cvp* pb) ;
static int vtysh_config_cmp_keys(const cvp* pa, const cvp* pb) ;

/*------------------------------------------------------------------------------
 * Create new config_item.
 *
 * Sets:
 *
 *       item->parent     ) set from parameters
 *       item->item_type  )
 *
 *       item->ordinal    ) set per collection
 *       item->daemons    )
 *
 *     and:
 *
 *       item->name       ) sets the items's name, if one is given, adding
 *       item->also       ) item to the lit for that name.
 *
 *       item->line         sets the line, if one is given
 *
 * Leaves everything else zeroised.  In particular, does *not* append the item
 * to any list, nor worry about any content type.
 */
static config_item
vtysh_config_item_new(config_collection collection, config_item parent,
                         config_item_type_t it, config_name name, elstring line)
{
  config_item item ;

  /* Zeroising sets:
   *
   *   parent             == X         -- set, below, from parameter
   *
   *   siblings           == all NULL
   *
   *   item_type          == X         -- set, below, from parameter
   *   ordinal            == X         -- set, below, per collection
   *   daemons            == X         -- set, below, per collection
   *
   *   node               == NULL_NODE -- required for it_node, only
   *
   *   content_type       == vct_none  )
   *   content_sorted     == false     )  no content parsing
   *   content_parser     == NULL      )
   *
   *   line               == empty     -- set, below, from parameter, if any
   *
   *   name               == NULL      -- set, below, from parameter, if any
   *   also               == NULL      -- set, below, from parameter, if any
   *
   *   key                == NULL      -- no key, yet
   *
   *   children           == all NULL  -- no children, yet
   *   subsections        == all NULL  -- no subsections, yet
   *
   *   merged_item        == NULL      -- nothing merged, yet;
   *   merged_daemons     == 0         -- none, yet
   *
   *   ctype              == sep_none
   */
  confirm(NULL_NODE  == 0) ;
  confirm(ELSTRING_INIT_ALL_ZEROS) ;
  confirm(vct_none   == 0) ;
  confirm(sep_none   == 0) ;

  item = XCALLOC(MTYPE_TMP, sizeof(config_item_t)) ;

  item->parent    = parent ;
  item->item_type = it ;
  item->ordinal   = ++collection->ordinal ;
  item->daemons   = collection->daemons ;

  if (name != NULL)
    {
      item->name   = name ;
      item->also   = name->list ;
      name->list   = item ;
    };

  if (line != NULL)
    *(item->line) = *line ;

  return item ;
} ;

/*------------------------------------------------------------------------------
 * Free all the items on the given list, and any children of those items.
 */
static void
vtysh_config_list_free(config_item parent, config_item_base_t* base)
{
  config_item child ;

  while ((child = ddl_pop(&child, *base, siblings)) != NULL)
    {
      qassert(parent == child->parent) ;

      vtysh_config_list_free(child, &(child->children)) ;
      vtysh_config_list_free(child, &(child->subsections)) ;

      XFREE(MTYPE_TMP, child) ;
    } ;
} ;

/*------------------------------------------------------------------------------
 * Close current parent, moving up to its parent.
 *
 * If the parent's current last item is it_dummy, it is now too late to
 * collect the pre-comment and add it to a real item, so convert to an empty
 * item, and merge if we can.
 *
 * Note that if the current parent is an node item, then it has no parent (it
 * has a NULL parent).
 */
static config_item
vtysh_config_parent_item_close(config_collection collection)
{
#if 0
  config_item item, grand_parent ;

  qassert(collection->parent_item != NULL) ;

  grand_parent = collection->parent_item->parent ;

  if      (collection->parent_item->item_type == it_node)
    assert(grand_parent == NULL) ;
  else if (collection->parent_item->item_type == it_group)
    assert(  (grand_parent->item_type == it_node)
           || (grand_parent->item_type == it_group) ) ;
  else
    assert(false) ;

  item = ddl_tail(collection->parent_item->children) ;

  if (item != NULL)
    assert(item->parent == collection->parent_item) ;

  if ((item != NULL) && (item->item_type == it_dummy))
    {
      assert(els_body_nn(item->line) == NULL) ;

      item->item_type = it_empty ;
      vtysh_config_set_empty_name(collection, item) ;

      vtysh_config_try_merge(collection, item) ;
    } ;

  return collection->parent_item = grand_parent ;
#endif
  return NULL ;
} ;





/*------------------------------------------------------------------------------
 * Insert an item (or items) into the collection, according to the current
 * content.
 *
 * A line has been read, and parsed as required, so that we have in the
 * collection:
 *
 *   * collection->line        -- the original line
 *
 *   * collection->parsed      -- the original line, tokenised
 *
 *   * collection->parent_item -- the current place in the collection
 *
 *   * collection->content     -- what we know about line
 *
 *       depth         -- current depth, before any content parsing
 *
 *       result        -- vcp_xxx -- see vty_vtysh_content.h
 *
 *       line_key      -- set if vcp_line  and parent is content_sorted
 *       group_key     -- set if vcp_group and parent is content_sorted
 *
 *       new_depth     )
 *       new_name      )  set if vcp_group or vcp_section
 *       new_type      )
 */
static cmd_ret_t
vtysh_config_item_insert(config_collection collection)
{
  config_item  parent ;
  vtysh_content_parse content ;

  parent  = collection->parent_item ;
  content = collection->content ;

  qassert(parent != NULL) ;


  /* If the content includes section or group setting, then we need to deal
   * with that first.
   *
   * This may create and/or select a new parent.
   */
  if (content->result & (vcp_group | vcp_section))
    {
      config_item_type_t it ;
      config_item grand_parent ;

      it = (content->result & vcp_group) ? it_group : it_section ;
      grand_parent = NULL ;

      /* 1: move up or down the stack as required.
       *
       * Set:  grand_parent to the parent of the parent to be selected -- NULL
       *       if the parent is selected here.
       *
       *       current parent, which may be selected if matches the required
       *       item type and name -- NULL if none to be considered.
       */
      if ((content->depth > content->new_depth) ||
                                                  (content->new_type == vct_end))
        {
          /* We are moving up the stack.
           *
           * Case 1: not vct_end, for example:
           *
           *   A: (0) --- node
           *           |
           *           +---> B: (1) --- group/section
           *           |             |
           *           .             +---> C: (2) --- group/section
           *           .             |             |
           *           .             .             .
           *           .             .             .
           *           .             .             = <- last_item
           *
           *   And we have: #section 1 item_type name
           *
           *   The current parent == collection->parent_item == "C".
           *
           *   We need the section of the given name and item_type, which is a child
           *   of the depth == 0 ancestor.
           *
           *   So we will set: grand_parent = "A"
           *                   parent       = "B"
           *
           *   If "B" is not a section, and does not have the right name, then
           *   will find/create the required section.
           *
           * Case 2: vct_end, for example:
           *
           *   A: (0) --- node
           *           |
           *           +---> B: (1) --- group/section
           *           |             |
           *           .             +---> C: (2) --- group/section
           *           .             |             |
           *           .             .             .
           *           .             .             .
           *           .             .             = <- last_item
           *
           *   And we have: #section 1 end
           *
           *   We proceed back to the depth 1 parent, and then step back and
           *   select its parent.  (If was "#section 2 end" would not need
           *   to move back very far.)
           *
           *   So we will set: grand_parent = NULL
           *                   parent       = "A"
           *
           *   Setting the grand_parent == NULL means the matter is settled.
           */
          if (content->new_depth == 0)
            return vtysh_config_error(collection, "new depth == 0") ;

          /* Proceed up the "stack" of groups/sections.
           *
           * Since the new_depth is >= 1, and the current depth is > new_depth
           * we start on an it_group/node and end up on one.
           */
          qassert( (parent->item_type == it_group) ||
                   (parent->item_type == it_section) ) ;

          while (content->depth > content->new_depth)
            {
              parent = parent->parent ;

              qassert(parent != NULL) ;
              qassert( (parent->item_type == it_group) ||
                       (parent->item_type == it_section) ) ;

              --content->depth ;
            } ;

          /* Now set the grand_parent -- which will be an it_node if depth
           * is 1, otherwise it_group/it_section.
           */
          grand_parent = parent->parent ;
          qassert(grand_parent != NULL) ;

          if (content->depth == 1)
            qassert(parent->item_type == it_node) ;
          else
            qassert( (parent->item_type == it_group) ||
                     (parent->item_type == it_section) ) ;

          /* If is vct_end, then we can now select the grand_parent, and we
           * are done.
           */
          if (content->new_type == vct_end)
            {
              if (parent->item_type != it)
                return vtysh_config_error(collection,
                         "group end for section or section end for group") ;

              parent = grand_parent ;
              grand_parent = NULL ;
            } ;
        }
      else if (content->new_depth > content->depth)
        {
          /* We are moving down the stack.
           *
           * For example:
           *
           *   A: (0) --- node
           *           |
           *           +---> B: (1) --- group/section
           *           |             |
           *           .             .
           *           .             = <- last_item
           *
           *   And we have: #section 2 item_type name
           *
           *   The current parent == collection->parent_item == "B".
           *
           *   We need the section of the given item_type and name, which is a child
           *   of current parent.
           *
           *   So we will set: grand_parent = "B"
           *                   parent       = NULL
           *
           *   And will then find/create the required section.
           */
          ++content->depth ;

          if (content->new_depth > content->depth)
            return vtysh_config_error(collection, "new depth > old_depth + 1") ;

          grand_parent = parent ;
          parent       = NULL ;
        } ;

      /* 2: select or create parent at the (now) current depth.
       *
       * If grand_parent == NULL, then we have set the new parent.
       *
       * Otherwise we want the group/section of the given item_type and name.
       * Groups and sections have separate name spaces.  If a group/section
       * with the given name already exists, it must have the same item_type.
       *
       * [It would be possible to may the item_type part of the name... but it seems
       *  that two sections with the same name but different types is more
       *  likely to be a mistake than deliberate.  Besides, to get the same
       *  effect the item_type could be explicitly added to the name.]
       *
       * If there is a current parent, then we can check that before doing the
       * name lookup, merge etc.
       */
      if (grand_parent != NULL)
        {
          if ( (parent == NULL)
              || (it != parent->item_type)
              || (strcmp(qs_string(content->new_name),
                                               (char*)parent->name->str) != 0) )
            {
              /* Cannot re-use the current parent, so need either to merge with
               * an existing one, create one.
               *
               * We can always merge with an existing it_section of the same
               * name.  For an it_group can merge with one of the same name if
               * are sorted, otherwise, must run the full merge.
               */
              config_name name ;

              name = vtysh_config_make_name(collection, grand_parent->ordinal,
                                                        it, content->new_name) ;
              parent = name->list ;

              if ((parent != NULL) && (it == it_group) &&
                                                 !grand_parent->content_sorted)
                parent = vtysh_config_merge_try(collection, grand_parent,
                                                                       parent) ;
              if (parent == NULL)
                {
                  /* There is nowhere to merge , so create a brand new
                   * it_section or it_group.
                   *
                   * Creating the item sets up everything that is required,
                   * except for the content type and except for appending to
                   * the required list.
                   */
                  parent = vtysh_config_item_new(collection, grand_parent, it,
                                                   name,
                          (content->result & vcp_meta_line) ? collection->line
                                                            : NULL) ;

                  parent->content_type   = content->new_type ;
                  parent->content_sorted =
                                       vtysh_content_sorted(content->new_type) ;
                  parent->content_parser =
                                       vtysh_content_parser(content->new_type) ;

                  if (it == it_group)
                    {
                      ddl_append(grand_parent->children, parent, siblings) ;
                      grand_parent->merged_item = NULL ;
                    }
                  else
                    {
                      ddl_append(grand_parent->subsections, parent, siblings) ;
                    } ;
                }
              else
                {
                  /* Can merge the section/group with an existing one.
                   */
                  parent->daemons |= collection->daemons ;
                } ;
            } ;
        } ;

      /* We have selected the group/section parent -- final check to
       * ensure its item_type matches the required type.
       */
      if (parent->content_type != content->new_type)
        return vtysh_config_error(collection, "new type != existing type") ;

      /* If the parent has changed......................................................
       */
      if (collection->parent_item != parent)
        {


          collection->parent_item = parent ;
        } ;
    } ;

  /* Having dealt with the parentage issues, merge in the line item, if there
   * is one.
   */
  if (content->result & vcp_line)
    {
      config_name name ;
      config_item item ;

      name = vtysh_config_make_name(collection, parent->ordinal, it_line,
                            cmd_tokens_concat(collection->parsed, 0,
                                              collection->parsed->num_tokens)) ;
      item = name->list ;

      if (item != NULL)
        {
          if (parent->content_sorted)
            {
              /* We try to overlay the highest equal line item which has no
               * daemons in common with the item being inserted.
               */
              config_item merge ;

              merge = NULL ;
              do
                {
                  if ((item->daemons & collection->daemons) == 0)
                    merge = item ;

                  item = item->also ;
                }
              while (item != NULL) ;

              item = merge ;
            }
          else
            {
              /* Full merge of item
               */
              item = vtysh_config_merge_try(collection, parent, item) ;
            } ;
        } ;

      if (item == NULL)
        {
          item = vtysh_config_item_new(collection, parent, it_line,
                                                       name, collection->line) ;
          ddl_append(parent->children, item, siblings) ;
        }
      else
        {
          ;
        } ;
    } ;

  return CMD_SUCCESS ;
} ;

/*------------------------------------------------------------------------------
 * See if can merge an it_line or it_group item.
 *
 * The given target item has the same name as an item to be inserted.
 *
 * Returns: if can merge, return the item that can merge with.
 *             otherwise, return NULL
 *
 * Records result for next time.
 */
static config_item
vtysh_config_merge_try(config_collection collection, config_item parent,
                                                             config_item target)
{
  config_item merge ;

  qassert((target->item_type == it_line) || (target->item_type == it_group)) ;

  if ((target == ddl_tail(parent->children)) && (target->also == NULL))
    {
      /* The target is the last child and the only possible target,
       * so we can either merge instantly or stop instantly.
       */
      merge = target ;
    }
  else
    {
      /* If the last operation on the parent was a merge, for the current set
       * of daemons, then we can try merging by scanning forwards from the
       * last merge.  This should help when merging large, similar lists.
       *
       * If not, then try merging by scanning upwards, collecting one or more
       * items to move above the chosen merge target (if any).
       */
      if ((parent->merged_item != NULL)
                             && (parent->merged_daemons == collection->daemons))
        merge = vtysh_config_merge_try_down(collection, parent, target) ;
      else
        merge = vtysh_config_merge_try_up(collection, &(parent->children),
                                                                       target) ;
    } ;

  parent->merged_item    = merge ;
  parent->merged_daemons = collection->daemons ;

  return merge ;
} ;

/*------------------------------------------------------------------------------
 * Attempt to merge, given that previous operation was a merge and we know
 * there is at least one target.
 *
 * The previous item inserted in the current parent was merged, and the current
 * last item has the same set of daemons as the previous item.  Can attempt a
 * further merge by searching *forwards* for a merge target.
 *
 * NB: since the previous operation was a merge, and the set of daemons is
 *     unchanged, we can *guarantee* that nothing forward of the previous
 *     merge has daemon(s) in common with the current item.
 *
 * NB: sadly, although we know there's at least one other item with the same
 *     name, we cannot tell whether there is one above or below the current
 *     merge position.  If this is a line item, we can make sure that there
 *     is at least one item we could merge with.
 */
static config_item
vtysh_config_merge_try_down(config_collection collection, config_item parent,
                                                             config_item target)
{
  config_item  merge ;
  config_name  item_name ;
  daemon_set_t item_daemons ;
  bool group ;

  group = (target->item_type == it_group) ;
  merge = parent->merged_item ;

  item_name    = target->name ;
  item_daemons = collection->daemons ;

  /* Expect to have a merged_item and merged_daemons.
   */
  qassert((merge != NULL) && (parent->merged_daemons == collection->daemons)) ;
  if ((merge == NULL) || (parent->merged_daemons != collection->daemons))
    return NULL ;

  /* If not group, will not merge with anything that has daemons in common with
   * the current ones.
   */
  if (!group)
    {
      config_item item ;

      item = item_name->list ;

      while (1)
        {
          if ((item->daemons & collection->daemons) == 0)
            break ;

          item = item->also ;

          if (item == NULL)
            return NULL ;
        } ;
    } ;

  /* Scan forwards for first match.
   *
   * Note that we start the scan with the last merged item, because we may
   * be merging a group item, in which case we could merge in the same
   * place.
   */
  while (1)
    {
      if (merge->name == item_name)
        {
          if (group || ((merge->daemons & item_daemons) == 0))
            return merge ;      /* found it     */
        }

      merge = ddl_next(merge, siblings) ;

      if (merge == NULL)
        return NULL ;
    } ;
} ;

/*------------------------------------------------------------------------------
 * Attempt to merge, given that there is at least one item with the same name
 * which might be able to merge with.
 *
 * Will not merge a line item with one which already has daemons in common with
 * the item to be inserted, but will merge section and group items.
 *
 * The search for a merge target starts at the end of the given list of
 * siblings and proceeds upwards.  While moving up can:
 *
 *   * step past items which have no daemons in common with the "bubbles"
 *     or with the item to be added.
 *
 *   * collect "bubbles" of items which have one or more daemons in common with
 *     the item to be added.
 *
 * If finds a merge position, collects together all the bubbles, and inserts
 * them immediately above the merge.
 *
 * If there is more than one possible merge position, will use the higher.
 */
static config_item
vtysh_config_merge_try_up(config_collection collection, config_item_base list,
                                                             config_item target)
{
  daemon_set_t item_daemons, bubble_daemons, total_daemons, target_daemons ;
  config_item  this, merged ;
  config_item_base_t  bubble ;
  uint                bubble_count ;
  uint                target_count ;
  vector              hat ;
  config_name  name ;
  bool         group ;

  name  = target->name ;
  group = (target->item_type == it_group) ;

  item_daemons = collection->daemons ;

  /* Check the first possible target.
   *
   * There should be one, but we get out now if not.
   *
   * We can merge group items which have daemons in common, but not line items,
   * so we can take that into account when counting possible targets.
   *
   * NB: items with the same name are put onto the name->list in arrival
   *     order.
   *
   *     Sibling items are not necessarily in arrival order, because merging
   *     changes the order, at least between daemons.
   *
   *     It's not practical to keep the name->list in the same order as the
   *     siblings.
   *
   *     But we can at least count how many possible targets there are.  And
   *     we can collect the set of daemons common to all possible targets.
   *
   * NB: for single daemon nodes/sections/groups this will short-circuit the
   *     merge.
   */
  this = name->list ;

  target_daemons = ~(daemon_set_t)0 ;
  target_count = 0 ;
  while (this != NULL)
    {
      if (group || ((this->daemons & item_daemons) == 0))
        ++target_count ;

      target_daemons &= this->daemons ;

      this = this->also ;
    } ;

  if (target_count == 0)
    return NULL ;

  /* Prepare: setting no bubbles and the current bubble empty.
   *
   *          bubble_daemons  = the daemons for the items in all bubbles.
   *
   *          total_daemons   = the daemons for the item to be merged plus the
   *                            daemons for all bubbles.
   *
   *          merged          = NULL -- nothing, yet
   *
   *          this            = last sibling
   *
   *          hat             = empty vector (reusing collection->hat)
   */
  bubble_count = 0 ;
  ddl_init(bubble) ;

  bubble_daemons = 0 ;
  total_daemons  = item_daemons ;

  merged = NULL ;
  this   = ddl_tail(*list) ;

  hat = vector_set_length(collection->hat, 0) ;

  /* Scan upwards, possibly adding to "bubble", looking a merge opportunity.
   *
   * We can add an item to the bubble iff it has one or more daemons in common
   * with the bubble (which includes the item).
   */
  while (1)
    {
      /* We expect to find something -- but bail out here if do not.
       */
      qassert(this != NULL) ;

      if (this == NULL)
        return merged ;

      /* See if we have found an item with the name we are looking for, and
       * proceed accordingly.
       */
      if (this->name == name)
        {
          /* We have reached a possible merge point.
           *
           * If this is a group item, we can merge provided we can slide the
           * bubble(s) past the merge position.
           *
           * If this is a line item, we can merge provided the item to be
           * inserted has no daemons in common with the target, and we can
           * slide the bubble past it.
           *
           * There is no point adding the target to the bubble(s), because
           * we won't be able to slide the target up to or past any higher
           * target -- because if we could, then the target would not be here
           * (it would itself have been merged !).
           */
          if (group)
            {
              if ((this->daemons & bubble_daemons) != 0)
                return merged ;
            }
          else
            {
              if ((this->daemons & total_daemons) != 0)
                return merged ;
            } ;

          /* Hurrah -- we have a merge.
           *
           * Collect together all the bubbles, slicing them out of the list,
           * then insert immediately above the merge position.
           */
          merged = this ;

          if (bubble_count > 0)
            {
              /* Cut the top-most bubble out of the list -- making bubble into
               * a valid list (the topmost bubble may be empty, but that is not
               * a problem).
               */
              ddl_slice(*list, bubble, siblings) ;

              /* Coalesce all other bubbles,
               */
              while (vector_length(hat) != 0)
                {
                  config_item_base_t part ;

                  part.head = vector_pop_item(hat) ;
                  part.tail = vector_pop_item(hat) ;

                  ddl_slice(*list, part, siblings) ;

                  ddl_append_list(bubble, part, siblings) ;
                } ;

              bubble_count = 1 ;

              /* Insert bubble before the merge point
               */
              ddl_splice_before(this, *list, bubble, siblings) ;

              /* Set this to be the top of the bubble, if there is one, so that
               * we continue searching from the next item above the bubble.
               */
              this = ddl_head(bubble) ;
            } ;

          /* If there is no further target, we are done.
           */
          --target_count ;

          if (target_count == 0)
            return merged ;
        }
      else
        {
          /* Not a match.
           *
           * If we can slide the bubble and the the item to be inserted past
           * the current item, then "close" the current bubble and continue.
           *
           * Otherwise, if we can slide the current item past all possible
           * targets, then add the current item to the top of the current
           * bubble.
           *
           * Otherwise, we can stop now.
           */
          if ((this->daemons & total_daemons) == 0)
            {
              /* Slide past
               */
              if (ddl_head(bubble) != NULL)
                {
                  vector_push_item(hat, ddl_tail(bubble)) ;
                  vector_push_item(hat, ddl_head(bubble)) ;

                  ddl_init(bubble) ;
                } ;
            }
          else if ((this->daemons & target_daemons) == 0)
            {
              /* Add this item to the top of the bubble
               */
              if (ddl_head(bubble) != NULL)
                {
                  ++bubble_count ;
                  bubble.tail = this ;
                } ;

              bubble.head = this ;

              bubble_daemons |= this->daemons ;
            }
          else
            {
              /* Cannot slide past current item, and current item cannot
               * slide past any of the possible targets.
               */
              return merged ;
            } ;
        } ;

      /* Step backwards to continue search
       */
      this = ddl_prev(this, siblings) ;
    } ;
} ;

/*------------------------------------------------------------------------------
 * Merge one set of pre-comment lines with an existing one.
 *
 * This is used where items are being merged.
 *
 * If the target pre-comment lines are unnamed, names them.  Then, name each
 * source pre-comment line and merge it in.
 */
static void
vtysh_config_merge_comment(config_collection collection,
                                         config_item target, config_item source)
{
#if 0
  config_item comment ;

  /* Get the trivial cases out of the way.
   */
  comment = ddl_head(source->pre_comments) ;
  if (comment == NULL)
    return ;

  comment = ddl_head(target->pre_comments) ;
  if (comment == NULL)
    {
      /* Move source pre-comments to target, and update parent of all of
       * those.
       */
      target->pre_comments = source->pre_comments ;
      ddl_init( source->pre_comments) ;

      comment = ddl_head(target->pre_comments) ;
      while (comment != NULL)
        {
          qassert(comment->parent == source) ;

          comment->parent = target ;

          comment = ddl_next(comment, siblings) ;
        } ;

      return ;
    } ;

  /* Name the target pre-comments, if required.
   */
  if (comment->name == NULL)
    {
      while (comment != NULL)
        {
          qassert(comment->parent == target) ;

          vtysh_config_set_comment_name(collection, comment) ;
          comment = ddl_next(comment, siblings) ;
        } ;
    } ;

  /* Now merge the source comments in
   */
  while (ddl_pop(&comment, source->pre_comments, siblings) != NULL)
    {
      config_item merged ;

      qassert(comment->parent == source) ;
      qassert(ddl_head(comment->pre_comments) == NULL) ;

      comment->parent = target ;
      vtysh_config_set_comment_name(collection, comment) ;
      ddl_append(target->pre_comments, comment, siblings) ;

      if (comment->name->list != NULL)
        merged = vtysh_config_merge_try_up(collection, &target->pre_comments,
                                                                      comment) ;
      else
        merged = NULL ;

      if (merged == NULL)
        ssl_push(comment->name->list, comment, also) ;
    } ;
#endif
} ;

/*------------------------------------------------------------------------------
 * Sort the given list of items
 *
 * If the items are:  it_node    -- this is sorting the collection->config into
 *                                  node number order
 *
 *                    it_section -- this is sorting an item->subsections list
 *                                  into section name order.
 *
 *                    it_group
 *                    it_line    -- this is sorting an item->children list into
 *                                  key order.
 */
static void
vtysh_config_list_sort(config_collection collection, config_item_base_t* base,
                                                          config_item_type_t it)
{
  config_item item ;
  vector hat ;
  vector_sort_cmp* cmp ;

  /* Start with an empty hat -- reuses the collection->hat
   */
  hat = vector_set_length(collection->hat, 0) ;

  /* Move list to vector.
   *
   * Note that for a list push/pop affect the head of the list, while for a
   * vector push/pop affect the end of the vector.
   */
  while ((item = ddl_pop(&item, *base, siblings)) != NULL)
    vector_push_item(hat, item) ;

  /* Select the sort function according to the item item_type, and sort.
   */
  switch (it)
    {
      case it_node:
        cmp = vtysh_config_cmp_nodes ;
        break ;

      case it_section:
        cmp = vtysh_config_cmp_sections ;
        break ;

      case it_group:
      case it_line:
        cmp = vtysh_config_cmp_keys ;

      default:
        assert(false) ;
    } ;

  vector_sort(hat, cmp) ;

  /* Move vector to list
   */
  while ((item = vector_pop_item(hat)) != NULL)
    ddl_push(*base, item, siblings) ;
} ;

/*------------------------------------------------------------------------------
 * Compare node items for sort
 */
static int
vtysh_config_cmp_nodes(const cvp* pa, const cvp* pb)
{
  const config_item_t* a ;
  const config_item_t* b ;

  a = *pa ;
  b = *pb ;

  qassert((a->item_type == it_node) && (b->item_type == it_node)) ;

  if (a->node != b->node)
    return (a->node < b->node) ? -1 : +1 ;

  qassert(false) ;

  return 0 ;
} ;

/*------------------------------------------------------------------------------
 * Compare section items for sort
 */
static int
vtysh_config_cmp_sections(const cvp* pa, const cvp* pb)
{
  const config_item_t* a ;
  const config_item_t* b ;
  int cmp ;

  a = *pa ;
  b = *pb ;

  qassert((a->item_type == it_section) && (b->item_type == it_section)) ;

  cmp = strcmp_mixed(a->name->str, b->name->str) ;

  if (cmp != 0)
    return cmp ;

  return (a < b) ? -1 : +1 ;
} ;

/*------------------------------------------------------------------------------
 * Compare items' keys for sort
 */
static int
vtysh_config_cmp_keys(const cvp* pa, const cvp* pb)
{
  const config_item_t* a ;
  const config_item_t* b ;
  int cmp ;

  a = *pa ;
  b = *pb ;

  qassert((a->item_type == it_group) || (a->item_type == it_line)) ;
  qassert((b->item_type == it_group) || (b->item_type == it_line)) ;

  cmp = strcmp_mixed(a->key, b->key) ;

  if (cmp != 0)
    return cmp ;

  return (a < b) ? -1 : +1 ;
} ;


/*==============================================================================
 * Raw configuration line handling
 *
 * When the configuration is fetched from each daemon, it arrives in a fifo.
 *
 * The contents of that fifo are co-opted into a config_part, which is appended
 * to the config_part list.
 *
 * Thereafter the raw lines are collected up into configuration items.  Each
 * config_part contains the configuration from a single daemon.  In
 * vtysh_config_collect_next_line() the contents of the part's fifo is broken
 * up into lines, returning an elstring containing each one.  Note that the
 * body of each line is in the original fifo, or in a fragment (if the line
 * straddles more than one fifo part).
 *
 * The item names also live in the fragment store.
 */
struct config_part
{
  config_part   next ;          /* List of parts in the collection      */

  vio_fifo      fifo ;

  /* For error reporting
   */
  qstring       name ;          /* Naming of Parts                      */
  uint          line_no ;

  /* The existing integrated configuration part is special, ...
   */
  bool          existing ;
} ;

typedef struct config_part  config_part_t ;

typedef struct config_fagment
{
  config_fragment  next ;

  char* ptr ;
  char* end ;

  char* last ;

  char  body[] ;

} config_fragment_t ;

/* First address in a fragment is aligned to void* boundary.
 */
CONFIRM((offsetof(config_fragment_t, body) % sizeof(void*)) == 0) ;

static void* vtysh_config_fragment_new(config_collection collection, ulen len,
                                                                   bool align) ;

/*------------------------------------------------------------------------------
 * Report an error related to the current configuration input line.
 */
static cmd_ret_t
vtysh_config_error(config_collection collection, const char* message)
{
  if (collection->part == NULL)
    {
      vty_out(collection->vtysh, "%% %s\n", message) ;
    }
  else
    {
      qstring temp ;

      temp = qs_set_els(NULL, collection->line) ;

      vty_out(collection->vtysh, "%% %s in %s\n", message,
                                            qs_string(collection->part->name)) ;
      vty_out(collection->vtysh, "%5u: %s\n", collection->part->line_no,
                                                              qs_string(temp)) ;
      qs_free(temp) ;
    } ;

  return CMD_ERROR ;
} ;

/*------------------------------------------------------------------------------
 * Create a new "part" object and append to the given collection.
 *
 * Accepts a qstring for the name of the part, which will be freed by
 * vtysh_config_part_free().
 *
 * Takes the given fifo, which will also be freed by vtysh_config_part_free().
 * Makes sure that any end_mark is unset, and sets a hold_mark, so that the
 * entire fifo is preserved when it is read.
 */
static config_part
vtysh_config_part_new(config_collection collection, qstring name,
                                                   vio_fifo fifo, bool existing)
{
  config_part  part ;

  part = XCALLOC(MTYPE_TMP, sizeof(config_part_t)) ;

  /* Zeroising has set:
   *
   *   next           -- NULL       -- not on list, yet
   *
   *   fifo           -- NULL       -- no fifo, yet
   *
   *   name           -- X          -- set, below
   *   line_no        -- 0          -- set, below
   *
   *   existing       -- X          -- set, below
   */
  dsl_append(collection->part_list, part, next) ;

  part->name  = name ;
  part->fifo  = fifo ;

  vio_fifo_clear_end_mark(part->fifo) ;
  vio_fifo_set_hold_mark(part->fifo) ;

  part->existing = existing ;

  return part ;
} ;

/*------------------------------------------------------------------------------
 * Destroy given "part" object (if any).
 *
 * Destroys any fifo and name.
 *
 * Returns NULL
 */
static config_part
vtysh_config_part_free(config_part part)
{
  if (part != NULL)
    {
      part->fifo = vio_fifo_free(part->fifo) ;
      part->name = qs_free(part->name) ;

      XFREE(MTYPE_TMP, part) ;
    } ;

  return NULL ;
} ;

/*------------------------------------------------------------------------------
 * Collect another part of configuration.
 *
 * Takes the contents of the given fifo, leaving it empty.
 */
static void
vtysh_config_collect(vty vtysh, vio_fifo buf, const char* name)
{
  qstring full_name ;

  /* Note that vtysh_config_part_new() takes responsibility for the full_name
   */
  full_name = qs_printf(NULL, "%s current configuration", name) ;

  vtysh_config_part_new(vtysh->collection, full_name, vio_fifo_move(NULL, buf),
                                              false /* not the "existing" */) ;
} ;

/*------------------------------------------------------------------------------
 * Add existing configuration as a final "part".
 *
 * Takes responsibility for the given fifo.
 */
static void
vtysh_config_collect_existing(vty vtysh, vio_fifo fifo, const char* name)
{
  qstring      full_name ;

  /* Note that vtysh_config_part_new() takes responsibility for the full_name
   * and for the fifo.
   */
  full_name = qs_printf(NULL, "existing %s", name) ;

  vtysh_config_part_new(vtysh->collection, full_name, fifo,
                                              true /* the "existing" */) ;
} ;

/*------------------------------------------------------------------------------
 * Set to the first part to be processed, if any
 *
 * Set collection->existing.
 */
static void
vtysh_config_collect_first_part(config_collection collection)
{
  collection->part = dsl_head(collection->part_list) ;

  collection->existing = (collection->part != NULL)
                                                 && collection->part->existing ;
} ;

/*------------------------------------------------------------------------------
 * Step to the next part to be processed, if any
 *
 * Update collection->existing.
 */
static void
vtysh_config_collect_next_part(config_collection collection)
{
  collection->part = collection->part->next ;

  collection->existing = (collection->part != NULL)
                                                 && collection->part->existing ;
} ;

/*------------------------------------------------------------------------------
 * Read next line of given part, trimming any trailing whitespace
 *
 * The line returned is a pointer into the fifo, or where a line straddles the
 * end of a fifo part, a piece of the part->fragments.
 *
 * The pointer *must* be treated as const char*.
 *
 * Returns:  true  <=> have another line
 *           false <=> at end of the part
 *
 * NB: even if the result is zero length, the address in the collection->line
 *     elstring will *not* be NULL.
 */
static bool
vtysh_config_collect_next_line(config_collection collection)
{
  uint     have ;
  const char* p, * e ;

  /* Do we have anything at all ?
   */
  have = vio_fifo_get(collection->part->fifo) ;

  if (have == 0)
    {
      els_clear(collection->line) ;     /* Let's be tidy        */

      return false ;
    } ;

  /* We are going to collect a line for the current daemon
   *
   * Hopefully we can do this in one go.
   */
  p = vio_fifo_get_ptr(collection->part->fifo) ;
  e = memchr(p, '\n', have) ;

  if (e != NULL)
    {
      const char* t ;

      t = e ;
      while ((t > p) && (*(t - 1) <= ' '))      /* trim whitespace      */
        --t ;

      els_set_n_nn(collection->line, p, t - p) ;

      ++e ;                             /* past the '\n'        */
    }
  else
    {
      /* Rats -- need to collect line fragments.
       */
      char* fragment ;
      bool  done ;
      ulen  len ;

      /* Collect into the collection->temp qstring.
       */
      qs_clear(collection->temp) ;
      done = false ;

      while (1)
        {
          qs_append_n(collection->temp, p, have) ;

          if (done)
            break ;

          have = vio_fifo_step_get(collection->part->fifo, have) ;

          if (have == 0)
            break ;

          p = vio_fifo_get_ptr(collection->part->fifo) ;
          e = memchr(p, '\n', have) ;

          if (e != NULL)
            {
              done = true ;
              have = e - p ;
              ++e ;             /* past the '\n'        */
            } ;
        } ;

      /* Move contents of qstring to fragments
       */
      qs_trim(collection->temp, '\0') ;
      len = qs_len_nn(collection->temp) ;

      fragment = vtysh_config_fragment_new(collection, len,
                                                          false /* no align*/) ;
      if (len != 0)
        memcpy(fragment, qs_char_nn(collection->temp), len) ;

      els_set_n_nn(collection->line, fragment, len) ;
    } ;

  vio_fifo_step(collection->part->fifo, e - p) ;

  ++collection->part->line_no ;

  return true ;
} ;

/*------------------------------------------------------------------------------
 * Get address of new fragment
 *
 * If "align" required, returns address on a void* boundary.
 *
 * NB: happily returns an address for a zero length fragment.
 */
static void*
vtysh_config_fragment_new(config_collection collection, ulen len, bool align)
{
  config_fragment  fragment ;
  char* ptr ;

  fragment = ssl_head(collection->fragment_list) ;

  if (fragment != NULL)
    {
      ptr = fragment->ptr ;

      if (align)
        ptr = (char*)((((uintptr_t)ptr + sizeof(void*) - 1) / sizeof(void*))
                                                            * sizeof(void*)) ;
      if ((ptr + len) > fragment->end)
        fragment = NULL ;
    } ;

  if (fragment == NULL)
    {
      uint size ;

      size = 16000 ;

      if (size < len)
        size = len ;

      size = (size + sizeof(config_fragment_t) + 0x0FFF) & ~0x0FFF ;

      fragment = XCALLOC(MTYPE_TMP, size) ;
      ssl_push(collection->fragment_list, fragment, next) ;

      fragment->ptr = fragment->body ;
      fragment->end = (char*)fragment + size ;

      ptr = fragment->ptr ;

      if (align)
        assert(((uintptr_t)ptr % sizeof(void*)) == 0) ;
    } ;

  fragment->ptr  = ptr + len ;
  fragment->last = ptr ;

  return ptr ;
} ;

/*------------------------------------------------------------------------------
 * Give back last fragment
 *
 * Used when finds that name already exists.
 */
static void
vtysh_config_fragment_return(config_collection collection, void* last)
{
  config_fragment  fragment ;

  fragment = ssl_head(collection->fragment_list) ;

  qassert(last == fragment->last) ;

  fragment->ptr = fragment->last ;
} ;

/*------------------------------------------------------------------------------
 * Free off all config raw line storage.
 */
static void
vtysh_config_raw_free(config_collection collection)
{
  while (dsl_head(collection->part_list) != NULL)
    {
      config_part  part ;

      part = dsl_pop(&part, collection->part_list, next) ;

      vtysh_config_part_free(part) ;
    } ;

  while (ssl_head(collection->fragment_list) != NULL)
    {
      config_fragment  fragment ;

      fragment = ssl_pop(&fragment, collection->fragment_list, next) ;

      XFREE(MTYPE_TMP, fragment) ;
    } ;

  qs_reset(collection->temp, keep_it) ;         /* embedded     */
  qs_reset(collection->comment, keep_it) ;      /* embedded     */
} ;

/*==============================================================================
 * Name handling.
 *
 * The name of an item covers:
 *
 *   * the ordinal of the parent item
 *
 *   * the item_type of item
 *
 *   * the item's "raw_name", which may be:
 *
 *       - the tokens which form the item, separated by spaces
 *
 *       - the entire line (for comments) less trailing whitespace
 *
 * While there is a single, global symbol table, the form of the name means
 * that each name has local scope within the parent.
 */

/*------------------------------------------------------------------------------
 * Make a name and either look it up in the collection's global name table,
 * or add new name entry to that table.
 *
 * Requires: item_type  -- it_node/it_section/...etc.
 *           ordinal    -- for it_node == node number
 *                         otherwise   == parent ordinal
 *           "raw name" -- may be NULL if the name is empty.
 *
 * All items with the same name share the same name object.  So, can test for
 * name equality by comparing name object addresses.
 *
 * The items to which a name applies are hung off the name->list entry, in
 * LIFO order.  At this point nothing is added to that list, hence a NULL
 * name->list entry implies this is a new name.
 *
 * The name is allocated in the fragments store, and that is added to the vhash
 * to track the existence of that name.  There is no need to worry freeing
 * names -- that is all taken care of when the fragments store is torn down.
 */
static config_name
vtysh_config_make_name(config_collection collection,
                                config_item_type_t item_type,
                                                 uint ordinal, qstring raw_name)
{
  ulen   len ;
  config_name temp, name ;
  bool added ;

  len  = qs_len(raw_name) ;

  temp = vtysh_config_fragment_new(collection,
                      offsetof(config_name_t, str[len+1]), true /* align */) ;

  temp->list = NULL ;
  temp->type = item_type ;
  temp->ord  = ordinal ;
  if (len != 0)
    memcpy(temp->str, qs_char_nn(raw_name), len) ;
  temp->str[len] = '\0' ;

  name = vhash_lookup(collection->match, temp, &added) ;

  if (added)
    {
      qassert(name == temp) ;
      vhash_set(name) ;
    }
  else
    vtysh_config_fragment_return(collection, temp) ;

  return name ;
} ;

/*------------------------------------------------------------------------------
 * Hash the given config_name.
 */
static vhash_hash_t
vtysh_config_name_hash(vhash_data_c data)
{
  vhash_hash_t hash ;
  const config_name_t* cname = data ;

  hash = vhash_hash_word(cname->type) ;
  hash = vhash_hash_word(cname->ord ^ hash) ;

  return vhash_hash_string_cont(cname->str, hash) ;
} ;

/*------------------------------------------------------------------------------
 * See if name in the given vhash_item and the given vhash_data are equal.
 *
 * In fact, both the vhash_item and the vhash_data are both config_names !
 */
static int
vtysh_config_match_equal(vhash_item_c item, vhash_data_c data)
{
  const config_name_t* a = item ;
  const config_name_t* b = data ;

  if (a->type != b->type)
    return 1 ;

  if (a->ord != b->ord)
    return 1 ;

  return strcmp((const char*)a->str, (const char*)b->str) ;
} ;

/*------------------------------------------------------------------------------
 * Create a new config_name to be added to the vhash, from the given vhash_data.
 *
 * In fact, the vhash_data is a temporary config_name, so we simply use that.
 */
static vhash_item
vtysh_config_match_new(vhash_table table, vhash_data_c data)
{
  return miyagi(data) ;
} ;

/*------------------------------------------------------------------------------
 * Free a config_name, when tearing down vhash.
 *
 * There is no need individually free names -- that is all taken care of when
 * the fragments store is torn down.
 */
static vhash_item
vtysh_config_match_free(vhash_item item, vhash_table table)
{
  return NULL ;
} ;

/*==============================================================================
 * The vtysh own configuration.
 *
 * There is not much of this.
 *
 * We don't write vtysh specific into file from vtysh. vtysh.conf should
 * be edited by hand.
 */

/*------------------------------------------------------------------------------
 * Show vtysh own configuration -- same like client daemon #vtysh-config-write
 *
 * This is for collecting the integrated configuration.
 */
static void
vtysh_config_own_config(vty vtysh)
{
  vty_out(vtysh, "#vtysh-config-daemon vtysh\n") ;
  vty_out(vtysh, "#vtysh-config-node %s\n", cmd_node_name(CONFIG_NODE)) ;

  if (host.name_set)
    vty_out(vtysh, "hostname %s\n", host.name) ;

  if (vtysh_integrated_vtysh_config)
    vty_out(vtysh, "service integrated-vtysh-config\n") ;
} ;

/*==============================================================================
 * For diagnostic purposes -- "show" functions for data structures.
 */

extern void show_collected(config_collection collection) ;
extern void show_collected_nodes(config_collection collection) ;
static void show_collected_item(config_item item, qstring line) ;

/*------------------------------------------------------------------------------
 * Output given collection to stderr
 */
extern void
show_collected(config_collection collection)
{
  config_part  lump ;
  uint         i ;

  lump = dsl_head(collection->part_list) ;

  fprintf(stderr, "The collected configuration lumps\n") ;

  i = 0 ;
  while (lump != NULL)
    {
      ++i ;

      fprintf(stderr, "---Lump %3d:\n", i) ;
      vio_fifo_fwrite(lump->fifo, stderr) ;

      lump = dsl_next(lump, next) ;
    } ;

  fprintf(stderr, "%d lumps\n", i) ;
} ;

/*------------------------------------------------------------------------------
 * Output nodes to stderr
 */
extern void
show_collected_nodes(config_collection collection)
{
#if 0
  config_item node_item ;
  qstring  line ;

  line = qs_new(200) ;

  /* Show where we are, and deal with any unexpected commentary !
   */
  node_item = ddl_head(collection->config) ;

  while (node_item != NULL)
    {
      config_item item ;

      fprintf(stderr, "# The collected %s node",
                                              cmd_node_name(collection->node)) ;

      item = ddl_head(collection->node_item->pre_comments) ;

      if (item != NULL)
        fprintf(stderr, " *** HAS PRE_COMMENTS ???") ;

      if (collection->node_item->post_sep != sep_none)
        {
          if (item != NULL)
            fprintf(stderr, " AND") ;

          fprintf(stderr, " *** HAS POST_SEP ???") ;
        } ;

      if (els_body(collection->node_item->line) != NULL)
        {
          if ((item != NULL) || (collection->node_item->post_sep != sep_none))
            fprintf(stderr, " AND") ;

          fprintf(stderr, " *** HAS LINE VALUE ???") ;
        } ;

      fprintf(stderr, "\n") ;

      show_collected_item(collection->node_item, line) ;
    } ;

  qs_free(line) ;
#endif
} ;

/*------------------------------------------------------------------------------
 * Output given item to stderr
 */
static void
show_collected_item(config_item item, qstring line)
{
#if 0
  config_item sub_item ;

  sub_item = ddl_head(item->pre_comments) ;

  while (sub_item != NULL)
    {
      show_collected_item(sub_item, line) ;

      sub_item = ddl_next(sub_item, siblings) ;
   } ;

  if (els_body(item->line) != NULL)
    {
      qs_set_els(line, item->line) ;
      fprintf(stderr, "%s\n", qs_string(line)) ;
    } ;

  switch (item->post_sep)
  {
    case sep_none:
      break ;

    case sep_blank:
      fprintf(stderr, "\n") ;
      break ;

    case sep_shriek:
      fprintf(stderr, "!\n") ;
      break ;

    case sep_hash:
      fprintf(stderr, "#\n") ;
      break ;

    default:
      fprintf(stderr, "#*** unknown post_sep %d ***\n", item->post_sep) ;
      break ;
  } ;

  sub_item = ddl_head(item->children) ;

  while (sub_item != NULL)
    {
      show_collected_item(sub_item, line) ;

      sub_item = ddl_next(sub_item, siblings) ;
   } ;
#endif
} ;

